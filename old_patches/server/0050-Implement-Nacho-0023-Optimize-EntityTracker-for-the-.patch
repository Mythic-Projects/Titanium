From 0dafefaf87fdab478dae52631fb55c1ae68f3bec Mon Sep 17 00:00:00 2001
From: Peridot <peridot491@protonmail.com>
Date: Wed, 11 May 2022 15:04:08 +0200
Subject: [PATCH] Implement [Nacho-0023] Optimize EntityTracker for the chunk
 updater


diff --git a/src/main/java/net/minecraft/server/EntityPlayer.java b/src/main/java/net/minecraft/server/EntityPlayer.java
index 6cd001b04..2ab55d8b5 100644
--- a/src/main/java/net/minecraft/server/EntityPlayer.java
+++ b/src/main/java/net/minecraft/server/EntityPlayer.java
@@ -5,6 +5,7 @@ import com.google.common.collect.Sets;
 import com.mojang.authlib.GameProfile;
 import io.netty.buffer.Unpooled;
 
+import it.unimi.dsi.fastutil.longs.LongOpenHashSet;
 import java.util.ArrayDeque;
 import java.util.ArrayList;
 import java.util.Arrays;
@@ -195,6 +196,10 @@ public class EntityPlayer extends EntityHuman implements ICrafting {
         this.playerConnection.sendPacket(new PacketPlayOutCombatEvent(this.bs(), PacketPlayOutCombatEvent.EnumCombatEventType.END_COMBAT));
     }
 
+    private long chunkToLong(int chunkX, int chunkZ) {
+        return ((long) chunkX << 32L) + chunkZ - -2147483648L;
+    }
+
     public void t_() {
         // CraftBukkit start
         if (this.joining) {
@@ -234,20 +239,20 @@ public class EntityPlayer extends EntityHuman implements ICrafting {
         }
 
         if (!this.chunkCoordIntPairQueue.isEmpty()) {
-            ArrayList arraylist = Lists.newArrayList();
+            ArrayList<Chunk> chunkList = Lists.newArrayList();
             Iterator iterator1 = this.chunkCoordIntPairQueue.iterator();
             ArrayList arraylist1 = Lists.newArrayList();
 
-            Chunk chunk;
+            Chunk chunk = null;
 
-            while (iterator1.hasNext() && arraylist.size() < world.spigotConfigTitanium.maxBulkChunks) { // Spigot
+            while (iterator1.hasNext() && chunkList.size() < world.spigotConfigTitanium.maxBulkChunks) { // Spigot
                 ChunkCoordIntPair chunkcoordintpair = (ChunkCoordIntPair) iterator1.next();
 
                 if (chunkcoordintpair != null) {
                     if (this.world.isLoaded(new BlockPosition(chunkcoordintpair.x << 4, 0, chunkcoordintpair.z << 4))) {
                         chunk = this.world.getChunkAt(chunkcoordintpair.x, chunkcoordintpair.z);
                         if (chunk.isReady()) {
-                            arraylist.add(chunk);
+                            chunkList.add(chunk);
                             arraylist1.addAll(chunk.tileEntities.values()); // CraftBukkit - Get tile entities directly from the chunk instead of the world
                             iterator1.remove();
                         }
@@ -257,11 +262,11 @@ public class EntityPlayer extends EntityHuman implements ICrafting {
                 }
             }
 
-            if (!arraylist.isEmpty()) {
-                if (arraylist.size() == 1) {
-                    this.playerConnection.sendPacket(new PacketPlayOutMapChunk((Chunk) arraylist.get(0), true, '\uffff'));
+            if (!chunkList.isEmpty()) {
+                if (chunkList.size() == 1) {
+                    this.playerConnection.sendPacket(new PacketPlayOutMapChunk(chunkList.get(0), true, '\uffff'));
                 } else {
-                    this.playerConnection.sendPacket(new PacketPlayOutMapChunkBulk(arraylist));
+                    this.playerConnection.sendPacket(new PacketPlayOutMapChunkBulk(chunkList));
                 }
 
                 Iterator iterator2 = arraylist1.iterator();
@@ -272,11 +277,33 @@ public class EntityPlayer extends EntityHuman implements ICrafting {
                     this.a(tileentity);
                 }
 
-                iterator2 = arraylist.iterator();
+//              //Nacho - if there are a lot of entities, we end up scanning the WHOLE list of entities multiple times
+//              // Which isn't the best if we have 100 players doing that
+                // So instead of updating all entities by chunk, we update all entities at once with a hashset of chunks
+                // This means we don't have to pass over the list x chunks
+                // o(chunk * entityList) => o(entitylist)
+
+//                Iterator<Chunk> chunkIterator = chunkList.iterator();
+//                while (chunkIterator.hasNext())
+//                {
+//                    chunk = (Chunk) chunkIterator.next();
+//                    this.u().getTracker().a(this, chunk);
+//                }
+//              Nacho - end
+
+                LongOpenHashSet chunkPosSet = new LongOpenHashSet(chunkList.size());
+                for (Chunk newChunk : chunkList) {
+                    chunkPosSet.add(this.chunkToLong(newChunk.locX, newChunk.locZ));
+                }
+
+                Iterator<EntityTrackerEntry> trackerEntryIterator = this.u().getTracker().getEntityTrackerEntries();
+                while (trackerEntryIterator.hasNext()) {
+                    EntityTrackerEntry entitytrackerentry = trackerEntryIterator.next();
 
-                while (iterator2.hasNext()) {
-                    chunk = (Chunk) iterator2.next();
-                    this.u().getTracker().a(this, chunk);
+                    if (entitytrackerentry.tracker != this && chunkPosSet.contains(this.chunkToLong(entitytrackerentry.tracker.ae, entitytrackerentry.tracker.ag)))
+                    {
+                        entitytrackerentry.updatePlayer(this);
+                    }
                 }
             }
         }
diff --git a/src/main/java/net/minecraft/server/EntityTracker.java b/src/main/java/net/minecraft/server/EntityTracker.java
index e24644c42..4668a1fca 100644
--- a/src/main/java/net/minecraft/server/EntityTracker.java
+++ b/src/main/java/net/minecraft/server/EntityTracker.java
@@ -239,6 +239,10 @@ public class EntityTracker {
 
     }
 
+    public Iterator<EntityTrackerEntry> getEntityTrackerEntries() {
+        return this.c.iterator();
+    }
+
     public void a(EntityPlayer entityplayer, Chunk chunk) {
         Iterator iterator = this.c.iterator();
 
-- 
2.36.0.windows.1

