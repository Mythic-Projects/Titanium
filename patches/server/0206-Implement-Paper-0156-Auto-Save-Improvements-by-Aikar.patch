From 3eb66ef23f0a964ef77bc2beb1fe8fce13fac9b9 Mon Sep 17 00:00:00 2001
From: Aikar <aikar@aikar.co>
Date: Mon, 19 Sep 2016 23:16:39 -0400
Subject: [PATCH] Implement [Paper-0156] Auto Save Improvements by Aikar


diff --git a/src/main/java/net/minecraft/server/Chunk.java b/src/main/java/net/minecraft/server/Chunk.java
index eee8537e2..44c1a5b6f 100644
--- a/src/main/java/net/minecraft/server/Chunk.java
+++ b/src/main/java/net/minecraft/server/Chunk.java
@@ -1059,11 +1059,10 @@ public class Chunk {
             if (this.r && this.world.getTime() != this.lastSaved || this.q) {
                 return true;
             }
-        } else if (this.r && this.world.getTime() >= this.lastSaved + MinecraftServer.getServer().autosavePeriod * 4) { // Spigot - Only save if we've passed 2 auto save intervals without modification
-            return true;
         }
 
-        return this.q;
+        // This !flag section should say if s(isModified) or t(hasEntities), then check auto save
+        return ((this.q || this.r) && this.world.getTime() >= this.lastSaved + world.paperConfigTitanium.autoSaveInterval); // Paper - Make world configurable and incremental
     }
 
     public Random a(long i) {
diff --git a/src/main/java/net/minecraft/server/ChunkProviderServer.java b/src/main/java/net/minecraft/server/ChunkProviderServer.java
index 9c841a9b6..593017bb9 100644
--- a/src/main/java/net/minecraft/server/ChunkProviderServer.java
+++ b/src/main/java/net/minecraft/server/ChunkProviderServer.java
@@ -390,7 +390,7 @@ public class ChunkProviderServer implements IChunkProvider {
                 this.saveChunk(chunk);
                 chunk.f(false);
                 ++i;
-                if (i == 24 && !flag && false) { // Spigot
+                if (!flag && i >= world.paperConfigTitanium.maxAutoSaveChunksPerTick) { // Spigot - // Paper - Incremental Auto Save - cap max per tick
                     return false;
                 }
             }
diff --git a/src/main/java/net/minecraft/server/EntityPlayer.java b/src/main/java/net/minecraft/server/EntityPlayer.java
index a3897b2f5..1b94a0894 100644
--- a/src/main/java/net/minecraft/server/EntityPlayer.java
+++ b/src/main/java/net/minecraft/server/EntityPlayer.java
@@ -29,6 +29,7 @@ public class EntityPlayer extends EntityHuman implements ICrafting {
 
     private static final Logger bH = LogManager.getLogger();
     public String locale = "en_US"; // Spigot
+    public long lastSave = MinecraftServer.currentTick; // Paper
     public PlayerConnection playerConnection;
     public final MinecraftServer server;
     public final PlayerInteractManager playerInteractManager;
diff --git a/src/main/java/net/minecraft/server/MinecraftServer.java b/src/main/java/net/minecraft/server/MinecraftServer.java
index 7751daf7d..35b656081 100644
--- a/src/main/java/net/minecraft/server/MinecraftServer.java
+++ b/src/main/java/net/minecraft/server/MinecraftServer.java
@@ -126,6 +126,7 @@ public abstract class MinecraftServer extends ReentrantIAsyncHandler<TasksPerTic
     public java.util.Queue<Runnable> processQueue = new java.util.concurrent.ConcurrentLinkedQueue<Runnable>();
     public java.util.Queue<Runnable> priorityProcessQueue = new java.util.concurrent.ConcurrentLinkedQueue<Runnable>(); // WindSpigot
     public int autosavePeriod;
+    public boolean serverAutoSave = false; // Paper
     // CraftBukkit end
 
     // WindSpigot - MSPT for tps command
@@ -954,24 +955,31 @@ public abstract class MinecraftServer extends ReentrantIAsyncHandler<TasksPerTic
             this.r.b().a(agameprofile);
         }
 
-        if (autosavePeriod > 0 && this.ticks % autosavePeriod == 0) { // CraftBukkit
-            // SpigotTimings.worldSaveTimer.startTiming(); // Spigot // Purpur
+        //if (autosavePeriod > 0 && this.ticks % autosavePeriod == 0) { // CraftBukkit // Paper - Incremental Auto Saving
             // this.methodProfiler.a("save"); // Purpur
-            this.v.savePlayers();
+            serverAutoSave = (autosavePeriod > 0 && this.ticks % autosavePeriod == 0); // Paper
+            int playerSaveInterval = TitaniumConfig.get().paper.settings.playerAutoSaveRate;
+            if (playerSaveInterval < 0) {
+                playerSaveInterval = autosavePeriod;
+            }
+            if (playerSaveInterval > 0) { // CraftBukkit // Paper
+                this.v.savePlayers(playerSaveInterval);
+            } // Paper - Incremental Auto Saving
+
+            // SpigotTimings.worldSaveTimer.startTiming(); // Spigot // Purpur
             // Spigot Start
             // We replace this with saving each individual world as this.saveChunks(...) is broken,
             // and causes the main thread to sleep for random amounts of time depending on chunk activity
             // Also pass flag to only save modified chunks
             server.playerCommandState = true;
             for (World world : worlds) {
-                world.getWorld().save(false);
+                if (world.paperConfigTitanium.autoSaveInterval > 0) world.getWorld().save(false); // Paper - Incremental / Configurable Auto Saving
             }
             server.playerCommandState = false;
             // this.saveChunks(true);
             // Spigot End
             // this.methodProfiler.b(); // Purpur
-            // SpigotTimings.worldSaveTimer.stopTiming(); // Spigot // Purpur
-        }
+        //} // Paper - Incremental Auto Saving
 
         // WindSpigot start - backport modern tick loop
         // Paper start
diff --git a/src/main/java/net/minecraft/server/PlayerList.java b/src/main/java/net/minecraft/server/PlayerList.java
index 03116263a..a675874c3 100644
--- a/src/main/java/net/minecraft/server/PlayerList.java
+++ b/src/main/java/net/minecraft/server/PlayerList.java
@@ -299,6 +299,7 @@ public abstract class PlayerList {
     }
 
     protected void savePlayerFile(EntityPlayer entityplayer) {
+        entityplayer.lastSave = MinecraftServer.currentTick; // Paper
         this.playerFileData.save(entityplayer);
         ServerStatisticManager serverstatisticmanager = (ServerStatisticManager) this.o.get(entityplayer.getUniqueID());
 
@@ -1109,12 +1110,23 @@ public abstract class PlayerList {
 
     }
 
+    // Paper start
     public void savePlayers() {
+        this.savePlayers(null);
+    }
+
+    public void savePlayers(Integer interval) {
+        long now = MinecraftServer.currentTick;
+        int numSaved = 0; // Paper
         for (int i = 0; i < this.players.size(); ++i) {
-            this.savePlayerFile((EntityPlayer) this.players.get(i));
+            EntityPlayer entityplayer = this.players.get(i);
+            if (interval == null || now - entityplayer.lastSave >= interval) {
+                this.savePlayerFile(entityplayer);
+                if (interval != null && ++numSaved <= TitaniumConfig.get().paper.settings.maxPlayersAutoSavePerTick) { break; } // Paper
+            }
         }
-
     }
+    // Paper end
 
     public void addWhitelist(GameProfile gameprofile) {
         this.whitelist.add(new WhiteListEntry(gameprofile));
diff --git a/src/main/java/net/minecraft/server/WorldServer.java b/src/main/java/net/minecraft/server/WorldServer.java
index b42f7cbdc..1c981cac2 100644
--- a/src/main/java/net/minecraft/server/WorldServer.java
+++ b/src/main/java/net/minecraft/server/WorldServer.java
@@ -988,7 +988,8 @@ public class WorldServer extends World implements IAsyncTaskHandler {
 
     public void save(boolean flag, IProgressUpdate iprogressupdate) throws ExceptionWorldConflict {
         if (this.chunkProvider.canSave()) {
-            org.bukkit.Bukkit.getPluginManager().callEvent(new org.bukkit.event.world.WorldSaveEvent(getWorld())); // CraftBukkit
+            if (flag) org.bukkit.Bukkit.getPluginManager().callEvent(new org.bukkit.event.world.WorldSaveEvent(getWorld())); // CraftBukkit // Paper - Incremental Auto Saving - Only fire event on full save
+            if (flag || server.serverAutoSave) { // Paper
             if (iprogressupdate != null) {
                 iprogressupdate.a("Saving level");
             }
@@ -997,6 +998,7 @@ public class WorldServer extends World implements IAsyncTaskHandler {
             if (iprogressupdate != null) {
                 iprogressupdate.c("Saving chunks");
             }
+            } // Paper
 
             this.chunkProvider.saveChunks(flag, iprogressupdate);
             // CraftBukkit - ArrayList -> Collection
diff --git a/src/main/java/net/titanium/config/PaperConfig.java b/src/main/java/net/titanium/config/PaperConfig.java
index 739d38d38..75cfd1e72 100644
--- a/src/main/java/net/titanium/config/PaperConfig.java
+++ b/src/main/java/net/titanium/config/PaperConfig.java
@@ -53,7 +53,7 @@ public class PaperConfig extends TitaniumConfigSection {
 
         @Comment("Maximum number of player data to save per tick.")
         @CustomKey("max-players-auto-save-per-tick")
-        public int maxPlayersAutoSavePerTick_ = 10;
+        public int maxPlayersAutoSavePerTick_ = -1;
         @Exclude
         public int maxPlayersAutoSavePerTick = 10;
 
diff --git a/src/main/java/net/titanium/config/PaperWorldConfig.java b/src/main/java/net/titanium/config/PaperWorldConfig.java
index 9897a8ece..ad52f0faf 100644
--- a/src/main/java/net/titanium/config/PaperWorldConfig.java
+++ b/src/main/java/net/titanium/config/PaperWorldConfig.java
@@ -243,6 +243,9 @@ public class PaperWorldConfig extends TitaniumConfigSection {
     @Exclude
     public int autoSaveInterval = -1;
 
+    @Comment("Maximum count of chunks that can be saved at 1 tick.")
+    public int maxAutoSaveChunksPerTick = 24;
+
     @Comment("Whether to enable certain features during world generation.")
     public GeneratorSettings generatorSettings = new GeneratorSettings();
 
-- 
2.36.0.windows.1

