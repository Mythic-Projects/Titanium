From f20af242a41db01e06631e84e09ced2821169710 Mon Sep 17 00:00:00 2001
From: Peridot <peridot491@protonmail.com>
Date: Sun, 5 Jun 2022 01:54:45 +0200
Subject: [PATCH] Implement [Nacho-????] Async entity tracker by Rastrian


diff --git a/src/main/java/me/rastrian/dev/PlayerMap.java b/src/main/java/me/rastrian/dev/PlayerMap.java
new file mode 100644
index 000000000..3a4eed97f
--- /dev/null
+++ b/src/main/java/me/rastrian/dev/PlayerMap.java
@@ -0,0 +1,232 @@
+package me.rastrian.dev;
+
+import it.unimi.dsi.fastutil.longs.Long2ObjectMap;
+import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap;
+import net.minecraft.server.EntityHuman;
+import net.minecraft.server.EntityPlayer;
+import net.minecraft.server.MathHelper;
+import net.minecraft.server.Packet;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.function.Consumer;
+import java.util.function.Function;
+import java.util.function.Predicate;
+
+public class PlayerMap {
+
+    private static final int CHUNK_BITS = 5;
+    private final Long2ObjectMap<List<EntityPlayer>> map = new Long2ObjectOpenHashMap<>();
+
+    private static long xzToKey(long x, long z) {
+        return (x << 32) + z - Integer.MIN_VALUE;
+    }
+
+    public void add(EntityPlayer player) {
+        int x = MathHelper.floor(player.locX) >> CHUNK_BITS;
+        int z = MathHelper.floor(player.locZ) >> CHUNK_BITS;
+        long key = xzToKey(x, z);
+        List<EntityPlayer> list = map.get(key);
+        if (list == null) {
+            list = new ArrayList<>();
+            map.put(key, list);
+        }
+        list.add(player);
+        player.playerMapX = x;
+        player.playerMapZ = z;
+    }
+
+    public void move(EntityPlayer player) {
+        int x = MathHelper.floor(player.locX) >> CHUNK_BITS;
+        int z = MathHelper.floor(player.locZ) >> CHUNK_BITS;
+
+        // did we move?
+        if (x == player.playerMapX && z == player.playerMapZ) {
+            return;
+        }
+
+        // do remove
+        long key = xzToKey(player.playerMapX, player.playerMapZ);
+        List<EntityPlayer> list = map.get(key);
+        list.remove(player);
+        if (list.isEmpty()) {
+            map.remove(key);
+        }
+
+        // do add
+        key = xzToKey(x, z);
+        list = map.get(key);
+        if (list == null) {
+            list = new ArrayList<>();
+            map.put(key, list);
+        }
+        list.add(player);
+        player.playerMapX = x;
+        player.playerMapZ = z;
+    }
+
+    public void remove(EntityPlayer player) {
+        long key = xzToKey(player.playerMapX, player.playerMapZ);
+        List<EntityPlayer> list = map.get(key);
+        if (list == null) {
+            // player has not yet been added to this playermap, this happens when teleporting to another world during PlayerJoinEvent
+            return;
+        }
+        list.remove(player);
+        if (list.isEmpty()) {
+            map.remove(key);
+        }
+    }
+
+    public void forEachNearby(double x, double y, double z, double distance, boolean useRadius, Consumer<EntityPlayer> function) {
+        for (int chunkX = MathHelper.floor(x - distance) >> CHUNK_BITS; chunkX <= MathHelper.floor(x + distance) >> CHUNK_BITS; chunkX++) {
+            for (int chunkZ = MathHelper.floor(z - distance) >> CHUNK_BITS; chunkZ <= MathHelper.floor(z + distance) >> CHUNK_BITS; chunkZ++) {
+                List<EntityPlayer> players = map.get(xzToKey(chunkX, chunkZ));
+                if (players != null) {
+                    for (EntityPlayer player : players) {
+                        if (!useRadius || player.e(x, y, z) < distance * distance) {
+                            function.accept(player);
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+    public EntityPlayer getNearestPlayer(double x, double y, double z, double distance) {
+        double bestDistanceSqrd = -1.0;
+        EntityPlayer bestPlayer = null;
+
+        for (int chunkX = MathHelper.floor(x - distance) >> CHUNK_BITS; chunkX <= MathHelper.floor(x + distance) >> CHUNK_BITS; chunkX++) {
+            for (int chunkZ = MathHelper.floor(z - distance) >> CHUNK_BITS; chunkZ <= MathHelper.floor(z + distance) >> CHUNK_BITS; chunkZ++) {
+                List<EntityPlayer> players = map.get(xzToKey(chunkX, chunkZ));
+                if (players != null) {
+                    for (EntityPlayer player : players) {
+                        double playerDistSqrd = player.e(x, y, z);
+                        if (playerDistSqrd < distance * distance && (bestDistanceSqrd == -1.0 || playerDistSqrd < bestDistanceSqrd)) {
+                            bestDistanceSqrd = playerDistSqrd;
+                            bestPlayer = player;
+                        }
+                    }
+                }
+            }
+        }
+        return bestPlayer;
+    }
+
+    public boolean isPlayerNearby(double x, double y, double z, double distance, boolean respectSpawningApi) {
+        for (int chunkX = MathHelper.floor(x - distance) >> CHUNK_BITS; chunkX <= MathHelper.floor(x + distance) >> CHUNK_BITS; chunkX++) {
+            for (int chunkZ = MathHelper.floor(z - distance) >> CHUNK_BITS; chunkZ <= MathHelper.floor(z + distance) >> CHUNK_BITS; chunkZ++) {
+                List<EntityPlayer> players = map.get(xzToKey(chunkX, chunkZ));
+                if (players != null) {
+                    for (EntityPlayer player : players) {
+                        if (player != null && !player.dead && (!respectSpawningApi || player.affectsSpawning)) {
+                            double playerDistSqrd = player.e(x, y, z);
+                            if (playerDistSqrd < distance * distance) {
+                                return true;
+                            }
+                        }
+                    }
+                }
+            }
+        }
+        return false;
+    }
+
+    public EntityPlayer getNearbyPlayer(double x, double y, double z, double distance, boolean respectSpawningApi) {
+        double bestDistanceSqrd = -1.0;
+        EntityPlayer bestPlayer = null;
+
+        for (int chunkX = MathHelper.floor(x - distance) >> CHUNK_BITS; chunkX <= MathHelper.floor(x + distance) >> CHUNK_BITS; chunkX++) {
+            for (int chunkZ = MathHelper.floor(z - distance) >> CHUNK_BITS; chunkZ <= MathHelper.floor(z + distance) >> CHUNK_BITS; chunkZ++) {
+                List<EntityPlayer> players = map.get(xzToKey(chunkX, chunkZ));
+                if (players != null) {
+                    for (EntityPlayer player : players) {
+                        if (player != null && !player.dead && (!respectSpawningApi || player.affectsSpawning)) {
+                            double playerDistSqrd = player.e(x, y, z);
+                            if (playerDistSqrd < distance * distance && (bestDistanceSqrd == -1.0 || playerDistSqrd < bestDistanceSqrd)) {
+                                bestDistanceSqrd = playerDistSqrd;
+                                bestPlayer = player;
+                            }
+                        }
+                    }
+                }
+            }
+        }
+
+        return bestPlayer;
+    }
+
+    public EntityPlayer getNearestAttackablePlayer(double x, double y, double z, double maxXZ, double maxY, Function<EntityHuman, Double> visibility) {
+        return getNearestAttackablePlayer(x, y, z, maxXZ, maxY, visibility, null);
+    }
+
+    public EntityPlayer getNearestAttackablePlayer(double x, double y, double z, double maxXZ, double maxY, Function<EntityHuman, Double> visibility, Predicate<EntityHuman> condition) {
+        double bestDistanceSqrd = -1.0;
+        EntityPlayer bestPlayer = null;
+
+        for (int chunkX = MathHelper.floor(x - maxXZ) >> CHUNK_BITS; chunkX <= MathHelper.floor(x + maxXZ) >> CHUNK_BITS; chunkX++) {
+            for (int chunkZ = MathHelper.floor(z - maxXZ) >> CHUNK_BITS; chunkZ <= MathHelper.floor(z + maxXZ) >> CHUNK_BITS; chunkZ++) {
+                List<EntityPlayer> players = map.get(xzToKey(chunkX, chunkZ));
+                if (players != null) {
+                    for (EntityPlayer player : players) {
+                        if (!player.abilities.isInvulnerable && player.isAlive() && (condition == null || condition.test(player))) {
+                            double dx = player.locX - x;
+                            double dz = player.locZ - z;
+                            double playerDistSqrd = dx * dx + dz * dz;
+                            double dy = Math.abs(player.locY - y);
+                            double distForPlayer = maxXZ;
+
+                            if (player.isSneaking()) {
+                                distForPlayer *= 0.8;
+                            }
+
+                            if (visibility != null) {
+                                Double v = visibility.apply(player);
+                                if (v != null) {
+                                    distForPlayer *= v;
+                                }
+                            }
+
+                            // mojang mistake squaring maxY?
+                            if ((maxY < 0.0 || dy < maxY * maxY) && playerDistSqrd < distForPlayer * distForPlayer && (bestDistanceSqrd == -1.0 || playerDistSqrd < bestDistanceSqrd)) {
+                                bestDistanceSqrd = playerDistSqrd;
+                                bestPlayer = player;
+                            }
+                        }
+                    }
+                }
+            }
+        }
+
+        return bestPlayer;
+    }
+
+    public void sendPacketNearby(EntityPlayer source, double x, double y, double z, double distance, Packet<?> packet, boolean self) {
+        for (int chunkX = MathHelper.floor(x - distance) >> CHUNK_BITS; chunkX <= MathHelper.floor(x + distance) >> CHUNK_BITS; chunkX++) {
+            for (int chunkZ = MathHelper.floor(z - distance) >> CHUNK_BITS; chunkZ <= MathHelper.floor(z + distance) >> CHUNK_BITS; chunkZ++) {
+                List<EntityPlayer> players = map.get(xzToKey(chunkX, chunkZ));
+                if (players != null) {
+                    for (EntityPlayer player : players) {
+                        // don't send self
+                        if (!self) {
+                            if (player == source) {
+                                continue;
+                            }
+                        }
+
+                        // bukkit visibility api
+                        if (source != null && !player.getBukkitEntity().canSee(source.getBukkitEntity())) {
+                            continue;
+                        }
+
+                        double playerDistSqrd = player.e(x, y, z);
+                        if (playerDistSqrd < distance * distance) {
+                            player.playerConnection.sendPacket(packet);
+                        }
+                    }
+                }
+            }
+        }
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/me/rastrian/dev/utils/IndexedLinkedHashSet.java b/src/main/java/me/rastrian/dev/utils/IndexedLinkedHashSet.java
new file mode 100644
index 000000000..5e89ec430
--- /dev/null
+++ b/src/main/java/me/rastrian/dev/utils/IndexedLinkedHashSet.java
@@ -0,0 +1,99 @@
+package me.rastrian.dev.utils;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.Set;
+
+public final class IndexedLinkedHashSet<E> implements Set<E> {
+
+    private final ArrayList<E> list = new ArrayList<>();
+    private final HashSet<E> set = new HashSet<>();
+
+    public boolean add(E e) {
+        if (set.add(e)) {
+            return list.add(e);
+        }
+        return false;
+    }
+
+    public boolean remove(Object o) {
+        if (set.remove(o)) {
+            return list.remove(o);
+        }
+        return false;
+    }
+
+    @Override
+    public boolean containsAll(Collection<?> c) {
+        return set.containsAll(c);
+    }
+
+    public void clear() {
+        set.clear();
+        list.clear();
+    }
+
+    public E get(int index) {
+        return list.get(index);
+    }
+
+    public boolean removeAll(Collection<?> c) {
+        if (set.removeAll(c)) {
+            return list.removeAll(c);
+        }
+        return true;
+    }
+
+    public boolean retainAll(Collection<?> c) {
+        if (set.retainAll(c)) {
+            return list.retainAll(c);
+        }
+        return false;
+    }
+
+    public boolean addAll(Collection<? extends E> c) {
+        boolean modified = false;
+        for (E e : c) {
+            if (add(e)) {
+                modified = true;
+            }
+        }
+        return modified;
+    }
+
+    @Override
+    public int size() {
+        return set.size();
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return set.isEmpty();
+    }
+
+    @Override
+    public boolean contains(Object o) {
+        return set.contains(o);
+    }
+
+    @Override
+    public Iterator<E> iterator() {
+        return list.iterator();
+    }
+
+    @Override
+    public Object[] toArray() {
+        return list.toArray();
+    }
+
+    @Override
+    public <T> T[] toArray(T[] a) {
+        return list.toArray(a);
+    }
+
+    public int indexOf(Object o) {
+        return list.indexOf(o);
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/net/minecraft/server/EntityPlayer.java b/src/main/java/net/minecraft/server/EntityPlayer.java
index b89849a10..7d5139fdc 100644
--- a/src/main/java/net/minecraft/server/EntityPlayer.java
+++ b/src/main/java/net/minecraft/server/EntityPlayer.java
@@ -35,7 +35,7 @@ public class EntityPlayer extends EntityHuman implements ICrafting {
     public double d;
     public double e;
     public final List<ChunkCoordIntPair> chunkCoordIntPairQueue = Lists.newLinkedList();
-    public final List<Integer> removeQueue = Lists.newLinkedList();
+    //public final List<Integer> removeQueue = Lists.newLinkedList(); // Rastrian/Nacho - Async entity tracker
     private final ServerStatisticManager bK;
     private float bL = Float.MIN_VALUE;
     private float bM = -1.0E8F;
@@ -51,6 +51,10 @@ public class EntityPlayer extends EntityHuman implements ICrafting {
     public boolean g;
     public int ping;
     public boolean viewingCredits;
+    // Rastrian/Nacho start - Async entity tracker
+    public int playerMapX;
+    public int playerMapZ;
+    // Nacho end
 
     // CraftBukkit start
     public String displayName;
@@ -215,7 +219,8 @@ public class EntityPlayer extends EntityHuman implements ICrafting {
             this.activeContainer = this.defaultContainer;
         }
 
-        while (!this.removeQueue.isEmpty()) {
+        // Rastrian/Nacho start - Async entity tracker
+        /*while (!this.removeQueue.isEmpty()) {
             int i = Math.min(this.removeQueue.size(), Integer.MAX_VALUE);
             int[] aint = new int[i];
             Iterator iterator = this.removeQueue.iterator();
@@ -227,7 +232,8 @@ public class EntityPlayer extends EntityHuman implements ICrafting {
             }
 
             this.playerConnection.sendPacket(new PacketPlayOutEntityDestroy(aint));
-        }
+        } */
+        // Nacho end
 
         if (!this.chunkCoordIntPairQueue.isEmpty()) {
             ArrayList<Chunk> chunkList = Lists.newArrayList();
@@ -939,7 +945,7 @@ public class EntityPlayer extends EntityHuman implements ICrafting {
         this.lastSentExp = -1;
         this.bM = -1.0F;
         this.bN = -1;
-        this.removeQueue.addAll(((EntityPlayer) entityhuman).removeQueue);
+        //this.removeQueue.addAll(((EntityPlayer) entityhuman).removeQueue); // Rastrian/Nacho - Async entity tracker
     }
 
     protected void a(MobEffect mobeffect) {
@@ -1069,12 +1075,13 @@ public class EntityPlayer extends EntityHuman implements ICrafting {
     }
 
     public void d(Entity entity) {
-        if (entity instanceof EntityHuman) {
-            this.playerConnection.sendPacket(new PacketPlayOutEntityDestroy(new int[] { entity.getId()}));
-        } else {
+        // Rastrian/Nacho start - Async entity tracker
+        /*if (entity instanceof EntityHuman) {*/
+            this.playerConnection.sendPacket(new PacketPlayOutEntityDestroy(entity.getId()));
+        /*} else {
             this.removeQueue.add(Integer.valueOf(entity.getId()));
-        }
-
+        }*/
+        // Rastrian/Nacho end
     }
 
     protected void B() {
diff --git a/src/main/java/net/minecraft/server/EntityTracker.java b/src/main/java/net/minecraft/server/EntityTracker.java
index 4668a1fca..4f1a55387 100644
--- a/src/main/java/net/minecraft/server/EntityTracker.java
+++ b/src/main/java/net/minecraft/server/EntityTracker.java
@@ -1,31 +1,54 @@
 package net.minecraft.server;
 
-import com.google.common.collect.Lists;
-import com.google.common.collect.Sets;
-import java.util.ArrayList;
+import com.google.common.util.concurrent.ThreadFactoryBuilder;
 import java.util.Iterator;
-import java.util.Set;
 import java.util.concurrent.Callable;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import me.rastrian.dev.utils.IndexedLinkedHashSet;
+import net.titanium.config.TitaniumConfig;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 
 public class EntityTracker {
 
-    private static final Logger a = LogManager.getLogger();
+    // Rastrian/Nacho start - Async entity tracker
+    /*
     private final WorldServer world;
     private Set<EntityTrackerEntry> c = new io.papermc.paper.util.maplist.ObjectMapList<>(); // IonSpigot - HashSet -> ObjectMapList
     public IntHashMap<EntityTrackerEntry> trackedEntities = new IntHashMap();
-    private int e;
+     */
+
+    private static final Logger a = LogManager.getLogger();
+
+    public IndexedLinkedHashSet<EntityTrackerEntry> c = new IndexedLinkedHashSet<>();
+    public IndexedLinkedHashSet<EntityTrackerEntry> getTrackedEntities() { return c; }
+
+    public IntHashMap<EntityTrackerEntry> trackedEntities = new IntHashMap<>();
+    public IntHashMap<EntityTrackerEntry> getTrackedEntityHashTable() { return trackedEntities; }
+
+    private int noTrackDistance = 0;
+    public int getNoTrackDistance() { return this.noTrackDistance; }
+    public void setNoTrackDistance(int noTrackDistance) { this.noTrackDistance = noTrackDistance; }
+
+    // parallel tracking
+    private static int trackerThreads = TitaniumConfig.get().entityTracking.async.baseThreads; // <-- 3 non-this threads, one this
+    private static ExecutorService POOL = Executors.newFixedThreadPool(trackerThreads - 1, new ThreadFactoryBuilder().setNameFormat("Entity Tracker Thread %d").build());
+    // Rastrian/Nacho end
+
+    private final int e;
 
     public EntityTracker(WorldServer worldserver) {
-        this.world = worldserver;
+        //this.world = worldserver; // Rastrian/Nacho - Async entity tracker
         this.e = worldserver.getMinecraftServer().getPlayerList().d();
     }
 
     public void track(Entity entity) {
         if (entity instanceof EntityPlayer) {
             this.addEntity(entity, 512, 2);
-            EntityPlayer entityplayer = (EntityPlayer) entity;
+            // Rastrian/Nacho start - Async entity tracker
+            /*EntityPlayer entityplayer = (EntityPlayer) entity;
             Iterator iterator = this.c.iterator();
 
             while (iterator.hasNext()) {
@@ -34,7 +57,8 @@ public class EntityTracker {
                 if (entitytrackerentry.tracker != entityplayer) {
                     entitytrackerentry.updatePlayer(entityplayer);
                 }
-            }
+            }*/
+            // Rastrian/Nacho end
         } else if (entity instanceof EntityFishingHook) {
             this.addEntity(entity, 64, 5, true);
         } else if (entity instanceof EntityArrow) {
@@ -102,14 +126,17 @@ public class EntityTracker {
 
         try {
             if (this.trackedEntities.b(entity.getId())) {
-                throw new IllegalStateException("Entity is already tracked!");
+                untrackEntity(entity); // Rastrian/Nacho - Async entity tracking
             }
 
-            EntityTrackerEntry entitytrackerentry = new EntityTrackerEntry(entity, i, j, flag);
+            EntityTrackerEntry entitytrackerentry = new EntityTrackerEntry(this, entity, i, j, flag);
 
             this.c.add(entitytrackerentry);
             this.trackedEntities.a(entity.getId(), entitytrackerentry);
-            entitytrackerentry.scanPlayers(this.world.players);
+            // Rastrian/Nacho start - Async entity tracking
+            //entitytrackerentry.scanPlayers(this.world.players);
+            entitytrackerentry.addNearPlayers();
+            // Rastrian/Nacho end
         } catch (Throwable throwable) {
             CrashReport crashreport = CrashReport.a(throwable, "Adding entity to track");
             CrashReportSystemDetails crashreportsystemdetails = crashreport.a("Entity To Track");
@@ -168,6 +195,8 @@ public class EntityTracker {
     }
 
     public void updatePlayers() {
+        // Rastrian/Nacho start - Async entity tracking
+        /*
         ArrayList arraylist = Lists.newArrayList();
         Iterator iterator = this.c.iterator();
 
@@ -192,7 +221,31 @@ public class EntityTracker {
                 }
             }
         }
+        */
+
+        int offset = 0;
+        final CountDownLatch latch = new CountDownLatch(trackerThreads);
+        for (int i = 1; i <= trackerThreads; i++) {
+            final int localOffset = offset++;
+            Runnable runnable = () -> {
+                /*
+                Loops the entire index hashset of registered entities.
+                In this loop it distributes the entities among the defined threads.
+                */
+                for (int n = localOffset; n < c.size(); n += trackerThreads) {
+                    c.get(n).update();
+                }
 
+                latch.countDown();
+            };
+
+            if (i < trackerThreads) POOL.execute(runnable); else runnable.run();
+        } try {
+            latch.await();
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+        // Rastrian/Nacho end
     }
 
     public void a(EntityPlayer entityplayer) {
@@ -202,7 +255,8 @@ public class EntityTracker {
             EntityTrackerEntry entitytrackerentry = (EntityTrackerEntry) iterator.next();
 
             if (entitytrackerentry.tracker == entityplayer) {
-                entitytrackerentry.scanPlayers(this.world.players);
+                // entitytrackerentry.scanPlayers(this.world.players);
+                entitytrackerentry.addNearPlayers();
             } else {
                 entitytrackerentry.updatePlayer(entityplayer);
             }
@@ -243,7 +297,8 @@ public class EntityTracker {
         return this.c.iterator();
     }
 
-    public void a(EntityPlayer entityplayer, Chunk chunk) {
+    // Rastrian/Nacho start - Async entity tracking
+    /*public void a(EntityPlayer entityplayer, Chunk chunk) {
         Iterator iterator = this.c.iterator();
 
         while (iterator.hasNext()) {
@@ -254,5 +309,6 @@ public class EntityTracker {
             }
         }
 
-    }
+    }*/
+    // Rastrian/Nacho end
 }
diff --git a/src/main/java/net/minecraft/server/EntityTrackerEntry.java b/src/main/java/net/minecraft/server/EntityTrackerEntry.java
index 8e9597417..527c47018 100644
--- a/src/main/java/net/minecraft/server/EntityTrackerEntry.java
+++ b/src/main/java/net/minecraft/server/EntityTrackerEntry.java
@@ -1,10 +1,13 @@
 package net.minecraft.server;
 
 import com.google.common.collect.Sets;
+import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Set;
+import java.util.function.Consumer;
+import net.titanium.config.TitaniumConfig;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 
@@ -46,7 +49,16 @@ public class EntityTrackerEntry {
     public Set<EntityPlayer> trackedPlayers = trackedPlayerMap.keySet();
     // PaperSpigot end
 
-    public EntityTrackerEntry(Entity entity, int i, int j, boolean flag) {
+    // Rastrian/Nacho start - Async entity tracking
+    private List<EntityPlayer> toRemove = new ArrayList<>();
+    private EntityTracker entityTracker;
+    private int addRemoveRate;
+    private int addRemoveCooldown;
+    private boolean withinNoTrack = false;
+    // Rastrian/Nacho end
+
+    public EntityTrackerEntry(EntityTracker entityTracker, Entity entity, int i, int j, boolean flag) {
+        this.entityTracker = entityTracker;
         this.tracker = entity;
         this.b = i;
         this.c = j;
@@ -58,6 +70,17 @@ public class EntityTrackerEntry {
         this.xRot = MathHelper.d(entity.pitch * 256.0F / 360.0F);
         this.i = MathHelper.d(entity.getHeadRotation() * 256.0F / 360.0F);
         this.y = entity.onGround;
+
+        if (!TitaniumConfig.get().entityTracking.async.enabled) {
+            this.addRemoveRate = 100;
+        } else if (this.tracker instanceof EntityArrow || this.tracker instanceof EntityProjectile) {
+            this.addRemoveRate = 5; // projectile things
+        } else if (this.tracker instanceof EntityPlayer) {
+            this.addRemoveRate = 5; // players
+        } else {
+            this.addRemoveRate = 10; // default
+        }
+        this.addRemoveCooldown = this.tracker.getId() % addRemoveRate;
     }
 
     public boolean equals(Object object) {
@@ -68,6 +91,79 @@ public class EntityTrackerEntry {
         return this.tracker.getId();
     }
 
+    // Rastrian/Nacho start - Async entity tracking
+    public void update() {
+        this.withinNoTrack = this.withinNoTrack();
+        if (--this.addRemoveCooldown <= 0) {
+            this.removeFarPlayers();
+            this.addNearPlayers();
+            this.addRemoveCooldown = this.addRemoveRate;
+        }
+
+        this.track(null);
+    }
+
+    private void removeFarPlayers() {
+        if (this.withinNoTrack) {
+            toRemove.addAll(this.trackedPlayers);
+            processToRemove();
+            return;
+        }
+
+        for (EntityPlayer entityplayer : (Collection<EntityPlayer>) trackedPlayers) {
+            double d0 = entityplayer.locX - this.tracker.locX;
+            double d1 = entityplayer.locZ - this.tracker.locZ;
+            int range = this.getRange();
+
+            if (!(d0 >= (double) (-range) && d0 <= (double) range && d1 >= (double) (-range) && d1 <= (double) range) || withinNoTrack()) {
+                toRemove.add(entityplayer);
+            }
+        }
+
+        this.processToRemove();
+    }
+
+    public void processToRemove() {
+        for (EntityPlayer entityPlayer : toRemove) {
+            entityPlayer.d(this.tracker);
+            this.trackedPlayers.remove(entityPlayer);
+        }
+
+        toRemove.clear();
+    }
+
+    public void addNearPlayers() {
+        addNearPlayers(false);
+    }
+
+    private void addNearPlayers(boolean updateCooldown) {
+        if (this.withinNoTrack) return;
+        if (updateCooldown) this.addRemoveCooldown = addRemoveRate;
+        this.tracker.world.playerMap.forEachNearby(this.tracker.locX, this.tracker.locY, this.tracker.locZ, this.getRange(), false, addNearPlayersConsumer);
+    }
+
+    private boolean withinNoTrack() {
+        return this.withinNoTrack(this.tracker);
+    }
+
+    private boolean withinNoTrack(Entity entity) {
+        if (!(entity instanceof EntityPlayer)) return false; // ensure all non-players are always tracked
+        double xDistSqrd = entity.locX * entity.locX;
+        double zDistSqrd = entity.locZ * entity.locZ;
+
+        int noTrackDistanceSqrd = entityTracker.getNoTrackDistance() * entityTracker.getNoTrackDistance();
+        return noTrackDistanceSqrd != 0 && xDistSqrd <= noTrackDistanceSqrd && zDistSqrd <= noTrackDistanceSqrd;
+    }
+
+    private final Consumer<EntityPlayer> addNearPlayersConsumer = new Consumer<EntityPlayer>() {
+
+        @Override
+        public void accept(EntityPlayer entityPlayer) {
+            if (TitaniumConfig.get().entityTracking.async.enabled || tracker.passenger == entityPlayer) updatePlayer(entityPlayer);
+        }
+    };
+    // Rastrian/Nacho end
+
     public void track(List<EntityHuman> list) {
         this.n = false;
         if (!this.isMoving || this.tracker.e(this.q, this.r, this.s) > 16.0D) {
@@ -76,7 +172,7 @@ public class EntityTrackerEntry {
             this.s = this.tracker.locZ;
             this.isMoving = true;
             this.n = true;
-            this.scanPlayers(list);
+            // this.scanPlayers(list); // Rastrian/Nacho - Async entity tracking
         }
 
         if (this.w != this.tracker.vehicle || this.tracker.vehicle != null && this.m % 60 == 0) {
@@ -153,11 +249,13 @@ public class EntityTrackerEntry {
                     } else {
                         this.y = this.tracker.onGround;
                         this.v = 0;
-                        // CraftBukkit start - Refresh list of who can see a player before sending teleport packet
+                        // Rastrian/Nacho start - Async entity tracking
+                        /*// CraftBukkit start - Refresh list of who can see a player before sending teleport packet
                         if (this.tracker instanceof EntityPlayer) {
                             this.scanPlayers(new java.util.ArrayList(this.tracker.world.players)); // [SportPaper-0203] Fix Teleport Invisibility this.trackedPlayers -> this.tracker.world.players
                         }
-                        // CraftBukkit end
+                        // CraftBukkit end*/
+                        // Rastrian/Nacho end
                         object = new PacketPlayOutEntityTeleport(this.tracker.getId(), i, j, k, (byte) l, (byte) i1, this.tracker.onGround);
                     }
                 }
@@ -334,10 +432,11 @@ public class EntityTrackerEntry {
     }
 
     public void updatePlayer(EntityPlayer entityplayer) {
-        org.spigotmc.AsyncCatcher.catchOp( "player tracker update"); // Spigot
+        //org.spigotmc.AsyncCatcher.catchOp( "player tracker update"); // Spigot
         if (entityplayer != this.tracker) {
             if (this.c(entityplayer)) {
                 if (!this.trackedPlayers.contains(entityplayer) && (this.e(entityplayer) || this.tracker.attachedToPlayer)) {
+                    if (this.tracker instanceof EntityPlayer && withinNoTrack()) return;
                     // CraftBukkit start - respect vanish API
                     if (this.tracker instanceof EntityPlayer) {
                         Player player = ((EntityPlayer) this.tracker).getBukkitEntity();
@@ -346,7 +445,7 @@ public class EntityTrackerEntry {
                         }
                     }
 
-                    entityplayer.removeQueue.remove(Integer.valueOf(this.tracker.getId()));
+                    //entityplayer.removeQueue.remove(Integer.valueOf(this.tracker.getId()));
                     // CraftBukkit end
                     this.trackedPlayerMap.put(entityplayer, true); // PaperBukkit
                     Packet packet = this.c();
@@ -455,12 +554,14 @@ public class EntityTrackerEntry {
         return entityplayer.u().getPlayerChunkMap().a(entityplayer, this.tracker.ae, this.tracker.ag);
     }
 
-    public void scanPlayers(List<EntityHuman> list) {
+    // Rastrian/Nacho start - Async entity tracking
+    /*public void scanPlayers(List<EntityHuman> list) {
         for (int i = 0; i < list.size(); ++i) {
             this.updatePlayer((EntityPlayer) list.get(i));
         }
 
-    }
+    }*/
+    // Rastrian/Nacho end
 
     private Packet c() {
         if (this.tracker.dead) {
@@ -572,10 +673,18 @@ public class EntityTrackerEntry {
         }
     }
 
+    // Rastrian/Nacho start - Async entity trakcking
+    public int getRange() {
+        if (this.tracker.passenger == null) {
+            return this.b;
+        }
+        return Math.max(this.b, org.spigotmc.TrackingRange.getEntityTrackingRange(this.tracker.passenger, 0));
+    }
+    // Rastrian/Nacho end
+
     public void clear(EntityPlayer entityplayer) {
         org.spigotmc.AsyncCatcher.catchOp( "player tracker clear"); // Spigot
-        if (this.trackedPlayers.contains(entityplayer)) {
-            this.trackedPlayers.remove(entityplayer);
+        if (this.trackedPlayers.remove(entityplayer)) {
             entityplayer.d(this.tracker);
         }
 
diff --git a/src/main/java/net/minecraft/server/PlayerList.java b/src/main/java/net/minecraft/server/PlayerList.java
index 426ee7c95..dc44faab0 100644
--- a/src/main/java/net/minecraft/server/PlayerList.java
+++ b/src/main/java/net/minecraft/server/PlayerList.java
@@ -53,7 +53,40 @@ public abstract class PlayerList {
     private static final SimpleDateFormat g = new SimpleDateFormat("yyyy-MM-dd \'at\' HH:mm:ss z");
     private final MinecraftServer server;
     public final List<EntityPlayer> players = new java.util.concurrent.CopyOnWriteArrayList(); // CraftBukkit - ArrayList -> CopyOnWriteArrayList: Iterator safety
-    private final Map<UUID, EntityPlayer> j = new Object2ObjectOpenHashMap<>();
+    //private final Map<UUID, EntityPlayer> j = Maps.newHashMap();
+    // PaperSpigot start - Player lookup improvements
+    public final Map<String, EntityPlayer> playerMap = new java.util.HashMap<String, EntityPlayer>() {
+        @Override
+        public EntityPlayer put(String key, EntityPlayer value) {
+            return super.put(key.toLowerCase(), value);
+        }
+
+        @Override
+        public EntityPlayer get(Object key) {
+            // put the .playerConnection check done in other places here
+            EntityPlayer player = super.get(key instanceof String ? ((String)key).toLowerCase() : key);
+            return (player != null && player.playerConnection != null) ? player : null;
+        }
+
+        @Override
+        public boolean containsKey(Object key) {
+            return get(key) != null;
+        }
+
+        @Override
+        public EntityPlayer remove(Object key) {
+            return super.remove(key instanceof String ? ((String)key).toLowerCase() : key);
+        }
+    };
+    public final Map<UUID, EntityPlayer> uuidMap = new java.util.HashMap<UUID, EntityPlayer>() {
+        @Override
+        public EntityPlayer get(Object key) {
+            // put the .playerConnection check done in other places here
+            EntityPlayer player = super.get(key instanceof String ? ((String)key).toLowerCase() : key);
+            return (player != null && player.playerConnection != null) ? player : null;
+        }
+    };
+    // PaperSpigot end
     private final GameProfileBanList k;
     private final IpBanList l;
     private final OpList operators;
@@ -308,7 +341,8 @@ public abstract class PlayerList {
     public void onPlayerJoin(EntityPlayer entityplayer, String joinMessage) { // CraftBukkit added param
         this.players.add(entityplayer);
         this.playersByName.put(entityplayer.getName(), entityplayer); // Spigot
-        this.j.put(entityplayer.getUniqueID(), entityplayer);
+        this.playerMap.put(entityplayer.getName(), entityplayer); // PaperSpigot
+        this.uuidMap.put(entityplayer.getUniqueID(), entityplayer); // PaperSpigot
         // this.sendAll(new PacketPlayOutPlayerInfo(PacketPlayOutPlayerInfo.EnumPlayerInfoAction.ADD_PLAYER, new EntityPlayer[] { entityplayer})); // CraftBukkit - replaced with loop below
         WorldServer worldserver = this.server.getWorldServer(entityplayer.dimension);
 
@@ -379,12 +413,15 @@ public abstract class PlayerList {
         worldserver.kill(entityplayer);
         worldserver.getPlayerChunkMap().removePlayer(entityplayer);
         this.players.remove(entityplayer);
+        this.uuidMap.remove(entityplayer.getUniqueID()); // PaperSpigot
+        this.playerMap.remove(entityplayer.getName()); // PaperSpigot
         this.playersByName.remove(entityplayer.getName()); // Spigot
         UUID uuid = entityplayer.getUniqueID();
-        EntityPlayer entityplayer1 = (EntityPlayer) this.j.get(uuid);
+        EntityPlayer entityplayer1 = (EntityPlayer) this.uuidMap.get(uuid);
 
         if (entityplayer1 == entityplayer) {
-            this.j.remove(uuid);
+            this.uuidMap.remove(uuid);
+            this.playerMap.remove(entityplayer.getName()); // PaperSpigot
             this.o.remove(uuid);
         }
 
@@ -627,7 +664,8 @@ public abstract class PlayerList {
             worldserver.addEntity(entityplayer1);
             this.players.add(entityplayer1);
             this.playersByName.put(entityplayer1.getName(), entityplayer1); // Spigot
-            this.j.put(entityplayer1.getUniqueID(), entityplayer1);
+            this.playerMap.put(entityplayer1.getName(), entityplayer1); // PaperSpigot
+            this.uuidMap.put(entityplayer1.getUniqueID(), entityplayer1);
         }
         // Added from changeDimension
         updateClient(entityplayer); // Update health, etc...
@@ -1047,7 +1085,7 @@ public abstract class PlayerList {
     }
 
     public EntityPlayer getPlayer(String s) {
-        return this.playersByName.get(s); // Spigot
+        return this.playerMap.get(s); // Spigot
     }
 
     public void sendPacketNearby(double d0, double d1, double d2, double d3, int i, Packet packet) {
@@ -1267,7 +1305,7 @@ public abstract class PlayerList {
     }
 
     public EntityPlayer a(UUID uuid) {
-        return (EntityPlayer) this.j.get(uuid);
+        return this.uuidMap.get(uuid);
     }
 
     public boolean f(GameProfile gameprofile) {
diff --git a/src/main/java/net/minecraft/server/World.java b/src/main/java/net/minecraft/server/World.java
index 6645e4cb4..0432f90b4 100644
--- a/src/main/java/net/minecraft/server/World.java
+++ b/src/main/java/net/minecraft/server/World.java
@@ -4,6 +4,7 @@ import com.google.common.base.Predicate;
 import com.google.common.collect.Lists;
 import com.google.common.collect.Maps;
 import com.google.common.collect.Sets;
+import me.rastrian.dev.PlayerMap;
 import me.suicidalkids.ion.blocks.movement.MovementCache;
 import net.titanium.config.IonWorldConfig;
 import net.titanium.config.PaperWorldConfig;
@@ -145,6 +146,8 @@ public abstract class World implements IBlockAccess {
     private org.spigotmc.TickLimiter entityLimiter;
     private org.spigotmc.TickLimiter tileLimiter;
     private int tileTickPosition;
+    public final PlayerMap playerMap = new PlayerMap();
+
     public ExecutorService lightingExecutor = Executors.newSingleThreadExecutor(new ThreadFactoryBuilder().setNameFormat("PaperSpigot - Lighting Thread").build()); // PaperSpigot - Asynchronous lighting updates
     public final Map<Explosion.CacheKey, Float> explosionDensityCache = new HashMap<Explosion.CacheKey, Float>(); // PaperSpigot - Optimize explosions
 
@@ -1146,6 +1149,7 @@ public abstract class World implements IBlockAccess {
                 EntityHuman entityhuman = (EntityHuman) entity;
 
                 this.players.add(entityhuman);
+                this.playerMap.add((EntityPlayer) entityhuman);
                 this.everyoneSleeping();
             }
 
@@ -1185,6 +1189,7 @@ public abstract class World implements IBlockAccess {
         if (entity instanceof EntityHuman) {
             this.players.remove(entity);
             this.worldMaps.removeTrackedPlayer((EntityHuman) entity); // FlamePaper - Minetick fix memory leaks
+            this.playerMap.remove((EntityPlayer) entity);
             // Spigot start
             for ( Object o : worldMaps.c )
             {
@@ -1213,6 +1218,7 @@ public abstract class World implements IBlockAccess {
         entity.die();
         if (entity instanceof EntityHuman) {
             this.players.remove(entity);
+            this.playerMap.remove((EntityPlayer) entity);
             this.worldMaps.removeTrackedPlayer((EntityHuman) entity); // FlamePaper - Minetick fix memory leaks
             this.everyoneSleeping();
         }
@@ -2958,11 +2964,11 @@ public abstract class World implements IBlockAccess {
     }
 
     public EntityHuman findNearbyPlayer(double d0, double d1, double d2, double d3) {
+        if (0 <= d3 && d3 <= 64) { return this.playerMap.getNearestPlayer(d0, d1, d2, d3); }
         double d4 = -1.0D;
         EntityHuman entityhuman = null;
 
-        for (int i = 0; i < this.players.size(); ++i) {
-            EntityHuman entityhuman1 = (EntityHuman) this.players.get(i);
+        for (EntityHuman entityhuman1 : a(EntityHuman.class, AxisAlignedBB.a(d0 - d3, d1 - d3, d2 - d3, d0 + d3, d1 + d3, d2 + d3))) {
             // CraftBukkit start - Fixed an NPE
             if (entityhuman1 == null || entityhuman1.dead) {
                 continue;
@@ -3004,6 +3010,7 @@ public abstract class World implements IBlockAccess {
     }
 
     public EntityHuman findNearbyPlayerWhoAffectsSpawning(double d0, double d1, double d2, double d3) {
+        if (0 <= d3 && d3 <= 64.0) { return this.playerMap.getNearbyPlayer(d0, d1, d2, d3, true); }
         double d4 = -1.0D;
         EntityHuman entityhuman = null;
 
diff --git a/src/main/java/net/minecraft/server/WorldManager.java b/src/main/java/net/minecraft/server/WorldManager.java
index 98164f253..1296a3804 100644
--- a/src/main/java/net/minecraft/server/WorldManager.java
+++ b/src/main/java/net/minecraft/server/WorldManager.java
@@ -25,12 +25,18 @@ public class WorldManager implements IWorldAccess {
 
     public void a(String s, double d0, double d1, double d2, float f, float f1) {
         // CraftBukkit - this.world.dimension
-        this.a.getPlayerList().sendPacketNearby(d0, d1, d2, f > 1.0F ? (double) (16.0F * f) : 16.0D, this.world.dimension, new PacketPlayOutNamedSoundEffect(s, d0, d1, d2, f, f1));
+        // Rastrian/Nacho start - Async entity tracking
+        //this.a.getPlayerList().sendPacketNearby(d0, d1, d2, f > 1.0F ? (double) (16.0F * f) : 16.0D, this.world.dimension, new PacketPlayOutNamedSoundEffect(s, d0, d1, d2, f, f1));
+        this.world.playerMap.sendPacketNearby(null, d0, d1, d2, f > 1.0F ? (double) (16.0F * f) : 16.0D, new PacketPlayOutNamedSoundEffect(s, d0, d1, d2, f, f1), false);
+        // Rastrian/Nacho end
     }
 
     public void a(EntityHuman entityhuman, String s, double d0, double d1, double d2, float f, float f1) {
         // CraftBukkit - this.world.dimension
-        this.a.getPlayerList().sendPacketNearby(entityhuman, d0, d1, d2, f > 1.0F ? (double) (16.0F * f) : 16.0D, this.world.dimension, new PacketPlayOutNamedSoundEffect(s, d0, d1, d2, f, f1));
+        // Rastrian/Nacho start - Async entity tracking
+        //this.a.getPlayerList().sendPacketNearby(entityhuman, d0, d1, d2, f > 1.0F ? (double) (16.0F * f) : 16.0D, this.world.dimension, new PacketPlayOutNamedSoundEffect(s, d0, d1, d2, f, f1));
+        this.world.playerMap.sendPacketNearby((EntityPlayer) entityhuman, d0, d1, d2, f > 1.0F ? (double) (16.0F * f) : 16.0D, new PacketPlayOutNamedSoundEffect(s, d0, d1, d2, f, f1), false);
+        // Rastrian/Nacho end
     }
 
     public void a(int i, int j, int k, int l, int i1, int j1) {}
@@ -45,7 +51,10 @@ public class WorldManager implements IWorldAccess {
 
     public void a(EntityHuman entityhuman, int i, BlockPosition blockposition, int j) {
         // CraftBukkit - this.world.dimension
-        this.a.getPlayerList().sendPacketNearby(entityhuman, (double) blockposition.getX(), (double) blockposition.getY(), (double) blockposition.getZ(), 64.0D, this.world.dimension, new PacketPlayOutWorldEvent(i, blockposition, j, false));
+        // Rastrian/Nacho start - Async entity tracking
+        //this.a.getPlayerList().sendPacketNearby(entityhuman, (double) blockposition.getX(), (double) blockposition.getY(), (double) blockposition.getZ(), 64.0D, this.world.dimension, new PacketPlayOutWorldEvent(i, blockposition, j, false));
+        this.world.playerMap.sendPacketNearby((EntityPlayer) entityhuman, blockposition.getX(), blockposition.getY(), blockposition.getZ(), 64.0D, new PacketPlayOutWorldEvent(i, blockposition, j, false), false);
+        // Rastrian/Nacho end
     }
 
     public void a(int i, BlockPosition blockposition, int j) {
@@ -66,9 +75,11 @@ public class WorldManager implements IWorldAccess {
             EntityPlayer entityplayer = (EntityPlayer) iterator.next();
 
             if (entityplayer != null && entityplayer.world == this.world && entityplayer.getId() != i) {
-                double d0 = (double) blockposition.getX() - entityplayer.locX;
+                // Ratrian/Nacho start - Async entity tracking
+                /*double d0 = (double) blockposition.getX() - entityplayer.locX;
                 double d1 = (double) blockposition.getY() - entityplayer.locY;
-                double d2 = (double) blockposition.getZ() - entityplayer.locZ;
+                double d2 = (double) blockposition.getZ() - entityplayer.locZ;*/
+                // Rastrian/Nacho end
 
                 // CraftBukkit start
                 if (entityhuman instanceof EntityPlayer && !entityplayer.getBukkitEntity().canSee(((EntityPlayer) entityhuman).getBukkitEntity())) {
@@ -76,12 +87,16 @@ public class WorldManager implements IWorldAccess {
                 }
                 // CraftBukkit end
 
-                if (d0 * d0 + d1 * d1 + d2 * d2 < 1024.0D) {
+                // Rastrian/Nacho start - Async entity tracking
+                //if (d0 * d0 + d1 * d1 + d2 * d2 < 1024.0D) {
                     // SportPaper start
                     if (packet == null) packet = new PacketPlayOutBlockBreakAnimation(i, blockposition, j);
-                    entityplayer.playerConnection.sendPacket(packet);
+                    //entityplayer.playerConnection.sendPacket(packet);
+                    this.world.playerMap.sendPacketNearby(entityplayer, blockposition.getX(), blockposition.getY(), blockposition.getZ(), 32.0D,
+                            new PacketPlayOutBlockBreakAnimation(i, blockposition, j), false);
                     // SportPaper end
-                }
+                //}
+                // Rastrian/Nacho end
             }
         }
 
diff --git a/src/main/java/net/titanium/config/TitaniumConfig.java b/src/main/java/net/titanium/config/TitaniumConfig.java
index 96a537233..d8aed0b73 100644
--- a/src/main/java/net/titanium/config/TitaniumConfig.java
+++ b/src/main/java/net/titanium/config/TitaniumConfig.java
@@ -131,6 +131,24 @@ public class TitaniumConfig extends TitaniumConfigSection {
 
     }
 
+    public EntityTracking entityTracking = new EntityTracking();
+
+    public static class EntityTracking extends TitaniumConfigSection {
+
+        public Async async = new Async();
+
+        public static class Async extends TitaniumConfigSection {
+
+            @Comment("Whether to use asynchronous entity tracking.")
+            public boolean enabled = true;
+
+            @Comment("The amount of threads to use for entity tracking (start value).")
+            public int baseThreads = 4;
+
+        }
+
+    }
+
     @Comment("When this option is enabled, the server will create a directory `legacy_configs` with files like bukkit.yml, spigot.yml etc.")
     @Comment("Changing option there will not affect the server, it's only mirror of this file.")
     @Comment("Enable this option only if some of your plugins are not compatible with the new configs.")
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftOfflinePlayer.java b/src/main/java/org/bukkit/craftbukkit/CraftOfflinePlayer.java
index 65f66c65e..79bb5f506 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftOfflinePlayer.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftOfflinePlayer.java
@@ -145,7 +145,10 @@ public class CraftOfflinePlayer implements OfflinePlayer, ConfigurationSerializa
     }
 
     public Player getPlayer() {
-        return server.getPlayer(getUniqueId());
+        // PaperSpigot - Improved player lookup, replace entire method
+        final EntityPlayer playerEntity = server.getHandle().uuidMap.get(getUniqueId());
+        return playerEntity != null ? playerEntity.getBukkitEntity() : null;
+        // PaperSpigot end
     }
 
     @Override
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftServer.java b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
index 56e73e37d..ae530e59d 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftServer.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
@@ -492,7 +492,7 @@ public final class CraftServer implements Server {
     public Player getPlayerExact(String name) {
         Validate.notNull(name, "Name cannot be null");
 
-        EntityPlayer player = playerList.getPlayer(name);
+        EntityPlayer player = playerList.playerMap.get(name);
         return (player != null) ? player.getBukkitEntity() : null;
     }
 
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
index 96e216539..bbd8a76ea 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
@@ -110,7 +110,7 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
     }
 
     public boolean isOnline() {
-        return server.getPlayer(getUniqueId()) != null;
+        return server.getHandle().uuidMap.get(getUniqueId()) != null; // PaperSpigot - replace whole method
     }
 
     public InetSocketAddress getAddress() {
diff --git a/src/main/java/org/spigotmc/TrackingRange.java b/src/main/java/org/spigotmc/TrackingRange.java
index f5e38264a..d1780cfae 100644
--- a/src/main/java/org/spigotmc/TrackingRange.java
+++ b/src/main/java/org/spigotmc/TrackingRange.java
@@ -1,7 +1,10 @@
 package org.spigotmc;
 
 import net.minecraft.server.Entity;
+import net.minecraft.server.EntityArrow;
+import net.minecraft.server.EntityEnderPearl;
 import net.minecraft.server.EntityExperienceOrb;
+import net.minecraft.server.EntityFishingHook;
 import net.minecraft.server.EntityGhast;
 import net.minecraft.server.EntityItem;
 import net.minecraft.server.EntityItemFrame;
@@ -24,29 +27,23 @@ public class TrackingRange
     {
         SpigotWorldConfig config = entity.world.spigotConfigTitanium;
         SpigotWorldConfig.EntityTrackingRange trackingConfig = config.entityTrackingRange;
-        if ( entity instanceof EntityPlayer )
-        {
+        if (entity instanceof EntityPlayer) {
             return trackingConfig.players;
-        }  else if ( entity.activationType == 1 )
-        {
+        } else if (entity instanceof EntityArrow || entity instanceof EntityEnderPearl || entity instanceof EntityFishingHook) {
+            return trackingConfig.players;
+        } else if (entity.activationType == 1) {
             return trackingConfig.monsters;
-        } else if ( entity instanceof EntityGhast )
-        {
-            if ( trackingConfig.monsters > config.entityActivationRange.monsters )
-            {
+        } else if (entity instanceof EntityGhast) {
+            if (trackingConfig.monsters > config.entityActivationRange.monsters) {
                 return trackingConfig.monsters;
-            } else
-            {
+            } else {
                 return config.entityActivationRange.monsters;
             }
-        } else if ( entity.activationType == 2 )
-        {
+        } else if (entity.activationType == 2) {
             return trackingConfig.animals;
-        } else if ( entity instanceof EntityItemFrame || entity instanceof EntityPainting || entity instanceof EntityItem || entity instanceof EntityExperienceOrb )
-        {
+        } else if (entity instanceof EntityItemFrame || entity instanceof EntityPainting || entity instanceof EntityItem || entity instanceof EntityExperienceOrb) {
             return trackingConfig.misc;
-        } else 
-        {
+        } else {
             return trackingConfig.other;
         }
     }
-- 
2.36.0.windows.1

