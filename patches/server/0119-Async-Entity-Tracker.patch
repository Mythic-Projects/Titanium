From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Rastrian <me@rastrian.dev>
Date: Fri, 17 Jun 2022 01:57:00 +0200
Subject: [PATCH] Async Entity Tracker

Co-authored-by: windcolor-dev <teaglehao@gmail.com>
Co-authored-by: Peridot <peridot491@protonmail.com>

diff --git a/build.gradle b/build.gradle
index ee2482a1f25ffd8353129cca8f29134ca96e26fd..9cd93691c6dfafd59c7f4dd905c4609d7828700e 100644
--- a/build.gradle
+++ b/build.gradle
@@ -32,6 +32,7 @@ dependencies {
     // PandaSpigot end
     implementation 'com.velocitypowered:velocity-native:1.1.9' // Nacho - Use Velocity natives & compression
     implementation 'com.eatthepath:fast-uuid:0.2.0' // Nacho - Use jchambers' FAST UUID methods
+    implementation 'com.github.matejtymes:javafixes:1.3.6.1' // WindSpigot
     // Titanium libraries end
 
     testImplementation 'junit:junit:4.13.2' // Titanium - Updated junit to 4.13.2
diff --git a/src/main/java/ga/windpvp/windspigot/async/ResettableLatch.java b/src/main/java/ga/windpvp/windspigot/async/ResettableLatch.java
new file mode 100644
index 0000000000000000000000000000000000000000..4e6a9435e3865d378962e88c1166973d9c5afa64
--- /dev/null
+++ b/src/main/java/ga/windpvp/windspigot/async/ResettableLatch.java
@@ -0,0 +1,42 @@
+package ga.windpvp.windspigot.async;
+
+import javafixes.concurrency.ReusableCountLatch;
+
+public class ResettableLatch extends ReusableCountLatch {
+
+    private int initValue;
+
+    public ResettableLatch() {
+        this(0);
+    }
+
+    public ResettableLatch(int initialCount) {
+        super(initialCount);
+        this.initValue = initialCount;
+    }
+
+    /*
+     * Resets this latch to its value when constructed
+     */
+    public void reset() {
+        reset(initValue);
+    }
+
+    /*
+     * Resets this latch to a value
+     */
+    public void reset(int count) {
+        if (getCount() > count) {
+            while (getCount() > count) {
+                // Decrease the thread count of the latch if it is too high
+                decrement();
+            }
+        } else if (getCount() < count) {
+            while (getCount() < count) {
+                // Increase the thread count of the latch if it is too low
+                increment();
+            }
+        }
+    }
+
+}
diff --git a/src/main/java/ga/windpvp/windspigot/async/entitytracker/AsyncEntityTracker.java b/src/main/java/ga/windpvp/windspigot/async/entitytracker/AsyncEntityTracker.java
new file mode 100644
index 0000000000000000000000000000000000000000..64706977a4a3ee84ee2b69f6428c026f43f1e2f3
--- /dev/null
+++ b/src/main/java/ga/windpvp/windspigot/async/entitytracker/AsyncEntityTracker.java
@@ -0,0 +1,56 @@
+package ga.windpvp.windspigot.async.entitytracker;
+
+import com.google.common.util.concurrent.ThreadFactoryBuilder;
+import ga.windpvp.windspigot.async.ResettableLatch;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.ThreadFactory;
+import net.minecraft.server.EntityTracker;
+import net.minecraft.server.WorldServer;
+import net.titanium.config.TitaniumConfig;
+import net.titanium.util.async.AsyncUtil;
+
+public class AsyncEntityTracker extends EntityTracker {
+
+    private static final int threadCount = TitaniumConfig.get().entityTracker.async.threads;
+    private static final ThreadFactory threadFactory = new ThreadFactoryBuilder().setNameFormat("Titanium - Entity Tracker Thread #%d").build();
+    private static final ExecutorService trackingThreadExecutorDispatcher = Executors.newSingleThreadExecutor(threadFactory);
+    private static final ExecutorService trackingThreadExecutor = Executors.newFixedThreadPool(threadCount, threadFactory);
+
+    private final ResettableLatch latch = new ResettableLatch(threadCount);
+
+    public AsyncEntityTracker(WorldServer worldserver) {
+        super(worldserver);
+    }
+
+    @Override
+    public void updatePlayers() {
+        int offset = 0;
+
+        for (int i = 1; i <= threadCount; i++) {
+            final int finalOffset = offset++;
+
+            AsyncUtil.run(() -> {
+                for (int index = finalOffset; index < c.size(); index += threadCount) {
+                    this.c.get(index).update();
+                }
+                latch.decrement();
+            }, trackingThreadExecutor);
+        }
+        try {
+            latch.waitTillZero();
+            latch.reset();
+        } catch (InterruptedException e) {
+            e.printStackTrace();
+        }
+    }
+
+    public static ExecutorService getDispatcher() {
+        return trackingThreadExecutorDispatcher;
+    }
+
+    public static ExecutorService getExecutor() {
+        return trackingThreadExecutor;
+    }
+
+}
diff --git a/src/main/java/ga/windpvp/windspigot/commons/ConcurrentIntHashMap.java b/src/main/java/ga/windpvp/windspigot/commons/ConcurrentIntHashMap.java
new file mode 100644
index 0000000000000000000000000000000000000000..1c88d3789d6ab7c6db37e8c8516ce8fe0144cf8f
--- /dev/null
+++ b/src/main/java/ga/windpvp/windspigot/commons/ConcurrentIntHashMap.java
@@ -0,0 +1,28 @@
+package ga.windpvp.windspigot.commons;
+
+import net.minecraft.server.IntHashMap;
+import static net.titanium.util.async.AsyncUtil.runSynchronized;
+
+public class ConcurrentIntHashMap<V> extends IntHashMap<V> {
+
+	public V get(int var1) {
+		return runSynchronized(this, () -> super.get(var1));
+	}
+
+	public boolean b(int var1) {
+		return runSynchronized(this, () -> super.b(var1));
+	}
+
+	public void a(int var1, V var2) {
+		runSynchronized(this, () -> super.a(var1, var2));
+	}
+
+	public V d(int var1) {
+		return runSynchronized(this, () -> super.d(var1));
+	}
+
+	public void c() {
+		runSynchronized(this, super::c);
+	}
+
+}
diff --git a/src/main/java/me/rastrian/dev/PlayerMap.java b/src/main/java/me/rastrian/dev/PlayerMap.java
new file mode 100644
index 0000000000000000000000000000000000000000..70d4abbd2b4e86a2fa60cb7e7a67e20b320b4d2e
--- /dev/null
+++ b/src/main/java/me/rastrian/dev/PlayerMap.java
@@ -0,0 +1,209 @@
+package me.rastrian.dev;
+
+import it.unimi.dsi.fastutil.longs.Long2ObjectArrayMap;
+import it.unimi.dsi.fastutil.longs.Long2ObjectMap;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.function.Consumer;
+import net.minecraft.server.EntityPlayer;
+import net.minecraft.server.MathHelper;
+import net.minecraft.server.Packet;
+
+public class PlayerMap {
+
+    private static final int CHUNK_BITS = 5;
+    private final Long2ObjectMap<List<EntityPlayer>> map = new Long2ObjectArrayMap<>();
+
+    private static long xzToKey(long x, long z) {
+        return (x << 32) + z - Integer.MIN_VALUE;
+    }
+
+    public void add(EntityPlayer player) {
+        int x = MathHelper.floor(player.locX) >> CHUNK_BITS;
+        int z = MathHelper.floor(player.locZ) >> CHUNK_BITS;
+        long key = xzToKey(x, z);
+        List<EntityPlayer> list = map.get(key);
+        if (list == null) {
+            list = new ArrayList<>();
+            map.put(key, list);
+        }
+        list.add(player);
+        player.playerMapX = x;
+        player.playerMapZ = z;
+    }
+
+    public void move(EntityPlayer player) {
+        int x = MathHelper.floor(player.locX) >> CHUNK_BITS;
+        int z = MathHelper.floor(player.locZ) >> CHUNK_BITS;
+
+        // did we move?
+        if (x == player.playerMapX && z == player.playerMapZ) {
+            return;
+        }
+
+        // do remove
+        long key = xzToKey(player.playerMapX, player.playerMapZ);
+        List<EntityPlayer> list = map.get(key);
+        // Titanium start - Fix NPE
+        if (list == null) {
+            this.add(player);
+            return;
+        }
+        // Titanium end
+        list.remove(player);
+        if (list.isEmpty()) {
+            map.remove(key);
+        }
+
+        // do add
+        key = xzToKey(x, z);
+        list = map.get(key);
+        if (list == null) {
+            list = new ArrayList<>();
+            map.put(key, list);
+        }
+        list.add(player);
+        player.playerMapX = x;
+        player.playerMapZ = z;
+    }
+
+    public void remove(EntityPlayer player) {
+        long key = xzToKey(player.playerMapX, player.playerMapZ);
+        List<EntityPlayer> list = map.get(key);
+        if (list == null) {
+            // player has not yet been added to this playermap, this happens when
+            // teleporting to another world during PlayerJoinEvent
+            return;
+        }
+        list.remove(player);
+        if (list.isEmpty()) {
+            map.remove(key);
+        }
+    }
+
+    public void forEachNearby(double x, double y, double z, double distance, boolean useRadius, Consumer<EntityPlayer> function) {
+        int chunkXMax = MathHelper.floor(x + distance) >> CHUNK_BITS;
+        int chunkZMax = MathHelper.floor(z + distance) >> CHUNK_BITS;
+
+        for (int chunkX = MathHelper.floor(x - distance) >> CHUNK_BITS; chunkX <= chunkXMax; chunkX++) {
+            for (int chunkZ = MathHelper.floor(z - distance) >> CHUNK_BITS; chunkZ <= chunkZMax; chunkZ++) {
+                List<EntityPlayer> players = map.get(xzToKey(chunkX, chunkZ));
+                if (players != null) {
+                    for (EntityPlayer player : players) {
+                        if (!useRadius || player.e(x, y, z) < distance * distance) {
+                            function.accept(player);
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+    public EntityPlayer getNearestPlayer(double x, double y, double z, double distance) {
+        double bestDistanceSqrd = -1.0;
+        EntityPlayer bestPlayer = null;
+
+        int chunkXMax = MathHelper.floor(x + distance) >> CHUNK_BITS;
+        int chunkZMax = MathHelper.floor(z + distance) >> CHUNK_BITS;
+
+        for (int chunkX = MathHelper.floor(x - distance) >> CHUNK_BITS; chunkX <= chunkXMax; chunkX++) {
+            for (int chunkZ = MathHelper.floor(z - distance) >> CHUNK_BITS; chunkZ <= chunkZMax; chunkZ++) {
+                List<EntityPlayer> players = map.get(xzToKey(chunkX, chunkZ));
+                if (players != null) {
+                    for (EntityPlayer player : players) {
+                        double playerDistSqrd = player.e(x, y, z);
+                        if (playerDistSqrd < distance * distance
+                                && (bestDistanceSqrd == -1.0 || playerDistSqrd < bestDistanceSqrd)) {
+                            bestDistanceSqrd = playerDistSqrd;
+                            bestPlayer = player;
+                        }
+                    }
+                }
+            }
+        }
+        return bestPlayer;
+    }
+
+    public boolean isPlayerNearby(double x, double y, double z, double distance, boolean respectSpawningApi) {
+        int chunkXMax = MathHelper.floor(x + distance) >> CHUNK_BITS;
+        int chunkZMax = MathHelper.floor(z + distance) >> CHUNK_BITS;
+
+        for (int chunkX = MathHelper.floor(x - distance) >> CHUNK_BITS; chunkX <= chunkXMax; chunkX++) {
+            for (int chunkZ = MathHelper.floor(z - distance) >> CHUNK_BITS; chunkZ <= chunkZMax; chunkZ++) {
+                List<EntityPlayer> players = map.get(xzToKey(chunkX, chunkZ));
+                if (players != null) {
+                    for (EntityPlayer player : players) {
+                        if (player != null && !player.dead && (!respectSpawningApi || player.affectsSpawning)) {
+                            double playerDistSqrd = player.e(x, y, z);
+                            if (playerDistSqrd < distance * distance) {
+                                return true;
+                            }
+                        }
+                    }
+                }
+            }
+        }
+        return false;
+    }
+
+    public EntityPlayer getNearbyPlayer(double x, double y, double z, double distance, boolean respectSpawningApi) {
+        double bestDistanceSqrd = -1.0;
+        EntityPlayer bestPlayer = null;
+
+        int chunkXMax = MathHelper.floor(x + distance) >> CHUNK_BITS;
+        int chunkZMax = MathHelper.floor(z + distance) >> CHUNK_BITS;
+
+        for (int chunkX = MathHelper.floor(x - distance) >> CHUNK_BITS; chunkX <= chunkXMax; chunkX++) {
+            for (int chunkZ = MathHelper.floor(z - distance) >> CHUNK_BITS; chunkZ <= chunkZMax; chunkZ++) {
+                List<EntityPlayer> players = map.get(xzToKey(chunkX, chunkZ));
+                if (players != null) {
+                    for (EntityPlayer player : players) {
+                        if (player != null && !player.dead && (!respectSpawningApi || player.affectsSpawning)) {
+                            double playerDistSqrd = player.e(x, y, z);
+                            if (playerDistSqrd < distance * distance
+                                    && (bestDistanceSqrd == -1.0 || playerDistSqrd < bestDistanceSqrd)) {
+                                bestDistanceSqrd = playerDistSqrd;
+                                bestPlayer = player;
+                            }
+                        }
+                    }
+                }
+            }
+        }
+
+        return bestPlayer;
+    }
+
+    public void sendPacketNearby(EntityPlayer source, double x, double y, double z, double distance, Packet<?> packet, boolean self) {
+        double distanceSqrd = distance * distance;
+        int chunkXMax = MathHelper.floor(x + distance) >> CHUNK_BITS;
+        int chunkZMax = MathHelper.floor(z + distance) >> CHUNK_BITS;
+
+        for (int chunkX = MathHelper.floor(x - distance) >> CHUNK_BITS; chunkX <= chunkXMax; chunkX++) {
+            for (int chunkZ = MathHelper.floor(z - distance) >> CHUNK_BITS; chunkZ <= chunkZMax; chunkZ++) {
+                List<EntityPlayer> players = map.get(xzToKey(chunkX, chunkZ));
+                if (players != null) {
+                    for (EntityPlayer player : players) {
+                        // don't send self
+                        if (!self) {
+                            if (player == source) {
+                                continue;
+                            }
+                        }
+
+                        // bukkit visibility api
+                        if (source != null && !player.getBukkitEntity().canSee(source.getBukkitEntity())) {
+                            continue;
+                        }
+
+                        double playerDistSqrd = player.e(x, y, z);
+                        if (playerDistSqrd < distanceSqrd) {
+                            player.playerConnection.sendPacket(packet);
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+}
\ No newline at end of file
diff --git a/src/main/java/me/suicidalkids/ion/visuals/CannonTrackerEntry.java b/src/main/java/me/suicidalkids/ion/visuals/CannonTrackerEntry.java
index d37dc29092e6ce833c512388ff0ea6b83b316b41..ffe921078d830211075921f09c4900c7dd83d446 100644
--- a/src/main/java/me/suicidalkids/ion/visuals/CannonTrackerEntry.java
+++ b/src/main/java/me/suicidalkids/ion/visuals/CannonTrackerEntry.java
@@ -43,7 +43,7 @@ public class CannonTrackerEntry extends EntityTrackerEntry {
 
         // This entity has moved 4 blocks since the last update, search for players
         if (this.tracker.e(updateX, updateY, updateZ) > 16.0D) {
-            this.scanPlayers(list);
+            // this.scanPlayers(list); // Nacho - Async Entity Tracker
             this.updateX = this.tracker.locX;
             this.updateY = this.tracker.locY;
             this.updateZ = this.tracker.locZ;
@@ -80,11 +80,16 @@ public class CannonTrackerEntry extends EntityTrackerEntry {
     public void updatePlayer(EntityPlayer entityplayer) {
         // Check configurable distance as a cube then visible distance.
         if (this.c(entityplayer) && this.tracker.h(entityplayer) < 4096.0D) {
+            // Nacho start - Async Entity Tracker
+            if (this.tracker instanceof EntityPlayer && withinNoTrack()) {
+                return;
+            }
+            // Nacho end
             if (this.trackedPlayers.contains(entityplayer) || (!this.e(entityplayer) && !this.tracker.attachedToPlayer)) {
                 return;
             }
 
-            entityplayer.removeQueue.remove(Integer.valueOf(this.tracker.getId()));
+            // entityplayer.removeQueue.remove(Integer.valueOf(this.tracker.getId())) // Nacho - Async Entity Tracker;
 
             this.trackedPlayerMap.put(entityplayer, true); // Paper
             Packet packet = this.createPacket(); // IonSpigot
@@ -101,8 +106,7 @@ public class CannonTrackerEntry extends EntityTrackerEntry {
             if (this.tracker.vehicle != null) {
                 entityplayer.playerConnection.sendPacket(new PacketPlayOutAttachEntity(0, this.tracker, this.tracker.vehicle));
             }
-        } else if (this.trackedPlayers.contains(entityplayer)) {
-            this.trackedPlayers.remove(entityplayer);
+        } else if (this.trackedPlayers.remove(entityplayer)) { // Nacho - Micro optimization
             entityplayer.d(this.tracker);
         }
     }
diff --git a/src/main/java/net/minecraft/server/EntityPlayer.java b/src/main/java/net/minecraft/server/EntityPlayer.java
index 6c0ab90c7bddac3022fe7e9a7ac52147f7b77aa4..d88128a68f56f82e743068d008c0f080f41dac8d 100644
--- a/src/main/java/net/minecraft/server/EntityPlayer.java
+++ b/src/main/java/net/minecraft/server/EntityPlayer.java
@@ -35,7 +35,7 @@ public class EntityPlayer extends EntityHuman implements ICrafting {
     public double d;
     public double e;
     public final List<ChunkCoordIntPair> chunkCoordIntPairQueue = Lists.newLinkedList();
-    public final java.util.Deque<Integer> removeQueue = new java.util.ArrayDeque<>(); // PandaSpigot
+    //public final java.util.Deque<Integer> removeQueue = new java.util.ArrayDeque<>(); // PandaSpigot // Nacho - Async entity tracker
     private final ServerStatisticManager bK;
     private float bL = Float.MIN_VALUE;
     private float bM = -1.0E8F;
@@ -51,6 +51,10 @@ public class EntityPlayer extends EntityHuman implements ICrafting {
     public boolean g;
     public int ping;
     public boolean viewingCredits;
+    // Nacho start - Async entity tracker
+    public int playerMapX;
+    public int playerMapZ;
+    // Nacho end
 
     // CraftBukkit start
     public String displayName;
@@ -215,7 +219,8 @@ public class EntityPlayer extends EntityHuman implements ICrafting {
             this.activeContainer = this.defaultContainer;
         }
 
-        while (!this.removeQueue.isEmpty()) {
+        // Nacho start - Async entity tracker
+        /*while (!this.removeQueue.isEmpty()) {
             int i = Math.min(this.removeQueue.size(), Integer.MAX_VALUE);
             int[] aint = new int[i];
             //Iterator iterator = this.removeQueue.iterator(); // PandaSpigot
@@ -226,7 +231,7 @@ public class EntityPlayer extends EntityHuman implements ICrafting {
                 aint[j++] = ((Integer) iterator.next()).intValue();
                 iterator.remove();
             } */
-            Integer integer;
+            /*Integer integer;
             while (j < i && (integer = this.removeQueue.poll()) != null) {
                 aint[j++] = integer;
             }
@@ -234,7 +239,8 @@ public class EntityPlayer extends EntityHuman implements ICrafting {
             // PandaSpigot end
 
             this.playerConnection.sendPacket(new PacketPlayOutEntityDestroy(aint));
-        }
+        }*/
+        // Nacho end
 
         if (!this.chunkCoordIntPairQueue.isEmpty()) {
             ArrayList<Chunk> chunkList = Lists.newArrayList();
@@ -953,9 +959,11 @@ public class EntityPlayer extends EntityHuman implements ICrafting {
         this.bN = -1;
         // PandaSpigot start
         //this.removeQueue.addAll(((EntityPlayer) entityhuman).removeQueue);
-        if (this.removeQueue != ((EntityPlayer) entityhuman).removeQueue) {
+        // Nacho start - Async entity tracker
+        /*if (this.removeQueue != ((EntityPlayer) entityhuman).removeQueue) {
             this.removeQueue.addAll(((EntityPlayer) entityhuman).removeQueue);
-        }
+        }*/
+        // Nacho end
         // PandaSpigot end
     }
 
@@ -1086,12 +1094,15 @@ public class EntityPlayer extends EntityHuman implements ICrafting {
     }
 
     public void d(Entity entity) {
-        if (entity instanceof EntityHuman) {
+        // Nacho start - Async entity tracker
+        /*if (entity instanceof EntityHuman) {
             this.playerConnection.sendPacket(new PacketPlayOutEntityDestroy(new int[] { entity.getId()}));
         } else {
             this.removeQueue.add(Integer.valueOf(entity.getId()));
-        }
+        }*/
+        // Nacho end
 
+        this.playerConnection.sendPacket(new PacketPlayOutEntityDestroy(entity.getId()));
     }
 
     protected void B() {
diff --git a/src/main/java/net/minecraft/server/EntityTracker.java b/src/main/java/net/minecraft/server/EntityTracker.java
index addf86937c1fbd0e8ead1e64637faa890ba7967f..342ee7dbe2a554d3b12eefb68bc7bce07818e5b7 100644
--- a/src/main/java/net/minecraft/server/EntityTracker.java
+++ b/src/main/java/net/minecraft/server/EntityTracker.java
@@ -3,9 +3,11 @@ package net.minecraft.server;
 import com.google.common.collect.Lists;
 import com.google.common.collect.Sets;
 import java.util.ArrayList;
+import ga.windpvp.windspigot.commons.ConcurrentIntHashMap;
 import java.util.Iterator;
 import java.util.Set;
 import java.util.concurrent.Callable;
+import net.titanium.util.IndexedLinkedSet;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 
@@ -13,19 +15,26 @@ public class EntityTracker {
 
     private static final Logger a = LogManager.getLogger();
     private final WorldServer world;
-    private Set<EntityTrackerEntry> c = new io.papermc.paper.util.maplist.ObjectMapList<>(); // IonSpigot - HashSet -> ObjectMapList
-    public IntHashMap<EntityTrackerEntry> trackedEntities = new IntHashMap();
+    // Nacho start - Async entity tracker
+    protected IndexedLinkedSet<EntityTrackerEntry> c = new IndexedLinkedSet<>();
+    public IntHashMap<EntityTrackerEntry> trackedEntities = new ConcurrentIntHashMap<>(); // WindSpigot
+    // Nacho end
+
     private int e;
 
     public EntityTracker(WorldServer worldserver) {
         this.world = worldserver;
-        this.e = worldserver.getMinecraftServer().getPlayerList().d();
+        // Nacho start - Async entity tracker
+        //this.e = worldserver.getMinecraftServer().getPlayerList().d();
+        this.e = 128;
+        // Nacho end
     }
 
     public void track(Entity entity) {
         if (entity instanceof EntityPlayer) {
             this.addEntity(entity, 512, 2);
-            EntityPlayer entityplayer = (EntityPlayer) entity;
+            // Nacho start - Async entity tracker
+            /*EntityPlayer entityplayer = (EntityPlayer) entity;
             Iterator iterator = this.c.iterator();
 
             while (iterator.hasNext()) {
@@ -34,7 +43,8 @@ public class EntityTracker {
                 if (entitytrackerentry.tracker != entityplayer) {
                     entitytrackerentry.updatePlayer(entityplayer);
                 }
-            }
+            }*/
+            // Nacho end
         } else if (entity instanceof EntityFishingHook) {
             this.addEntity(entity, 64, 5, true);
         } else if (entity instanceof EntityArrow) {
@@ -102,14 +112,20 @@ public class EntityTracker {
 
         try {
             if (this.trackedEntities.b(entity.getId())) {
-                throw new IllegalStateException("Entity is already tracked!");
+                // Nacho start - Async entity tracker
+                //throw new IllegalStateException("Entity is already tracked!");
+                untrackEntity(entity);
+                // Nacho end
             }
 
             EntityTrackerEntry entitytrackerentry = createTracker(entity, i, j, flag); // IonSpigot
 
             this.c.add(entitytrackerentry);
             this.trackedEntities.a(entity.getId(), entitytrackerentry);
-            entitytrackerentry.scanPlayers(this.world.players);
+            // Nacho start - Async entity tracker
+            //entitytrackerentry.scanPlayers(this.world.players);
+            entitytrackerentry.addNearPlayers();
+            // Nacho end
         } catch (Throwable throwable) {
             CrashReport crashreport = CrashReport.a(throwable, "Adding entity to track");
             CrashReportSystemDetails crashreportsystemdetails = crashreport.a("Entity To Track");
@@ -145,7 +161,7 @@ public class EntityTracker {
 
     }
     // IonSpigot start
-    private EntityTrackerEntry createTracker(Entity entity, int i, int j, boolean flag) {
+    protected EntityTrackerEntry createTracker(Entity entity, int i, int j, boolean flag) {
         if (entity.isCannoningEntity && world.ionConfigTitanium.tnt.useFasterTracker) {
             return new me.suicidalkids.ion.visuals.CannonTrackerEntry(entity, i, j, flag);
         } else {
@@ -177,7 +193,11 @@ public class EntityTracker {
     }
 
     public void updatePlayers() {
-        ArrayList arraylist = Lists.newArrayList();
+        // Nacho start - Async entity tracker
+        for (EntityTrackerEntry entry : c) {
+            entry.update();
+        }
+        /*ArrayList arraylist = Lists.newArrayList();
         Iterator iterator = this.c.iterator();
 
         while (iterator.hasNext()) {
@@ -200,8 +220,8 @@ public class EntityTracker {
                     entitytrackerentry1.updatePlayer(entityplayer);
                 }
             }
-        }
-
+        }*/
+        // Nacho end
     }
 
     public void a(EntityPlayer entityplayer) {
@@ -211,7 +231,10 @@ public class EntityTracker {
             EntityTrackerEntry entitytrackerentry = (EntityTrackerEntry) iterator.next();
 
             if (entitytrackerentry.tracker == entityplayer) {
-                entitytrackerentry.scanPlayers(this.world.players);
+                // Nacho start - Async entity tracker
+                //entitytrackerentry.scanPlayers(this.world.players);
+                entitytrackerentry.addNearPlayers();
+                // Nacho end
             } else {
                 entitytrackerentry.updatePlayer(entityplayer);
             }
@@ -252,7 +275,8 @@ public class EntityTracker {
         return this.c.iterator();
     }
 
-    public void a(EntityPlayer entityplayer, Chunk chunk) {
+    // Nacho start - Async entity tracker
+    /*public void a(EntityPlayer entityplayer, Chunk chunk) {
         Iterator iterator = this.c.iterator();
 
         while (iterator.hasNext()) {
@@ -263,5 +287,6 @@ public class EntityTracker {
             }
         }
 
-    }
+    }*/
+    // Nacho end
 }
diff --git a/src/main/java/net/minecraft/server/EntityTrackerEntry.java b/src/main/java/net/minecraft/server/EntityTrackerEntry.java
index cf1ac2c43fe5f7bf4baf539d88e7a0f8b8397a2a..0b2b02fd4b8a79f916e95699d2f96344eee5c7c5 100644
--- a/src/main/java/net/minecraft/server/EntityTrackerEntry.java
+++ b/src/main/java/net/minecraft/server/EntityTrackerEntry.java
@@ -1,10 +1,14 @@
 package net.minecraft.server;
 
 import com.google.common.collect.Sets;
+import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Set;
+import java.util.function.Consumer;
+import net.titanium.config.TitaniumConfig;
+import net.titanium.util.MathUtil;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 
@@ -46,7 +50,14 @@ public class EntityTrackerEntry {
     public Set<EntityPlayer> trackedPlayers = trackedPlayerMap.keySet();
     // PaperSpigot end
 
+    // Nacho start - Async entity tracker
+    protected List<EntityPlayer> toRemove = new ArrayList<>();
+    protected int addRemoveRate;
+    protected int addRemoveCooldown;
+    protected boolean withinNoTrack = false;
+
     public EntityTrackerEntry(Entity entity, int i, int j, boolean flag) {
+        // Nacho end
         this.tracker = entity;
         this.b = i;
         this.c = j;
@@ -58,6 +69,19 @@ public class EntityTrackerEntry {
         this.xRot = MathHelper.d(entity.pitch * 256.0F / 360.0F);
         this.i = MathHelper.d(entity.getHeadRotation() * 256.0F / 360.0F);
         this.y = entity.onGround;
+
+        // Nacho start - Async entity tracker
+        if (!TitaniumConfig.get().entityTracker.async.enabled) {
+            this.addRemoveRate = 100;
+        } else if (this.tracker instanceof EntityArrow || this.tracker instanceof EntityProjectile) {
+            this.addRemoveRate = 5; // projectile things
+        } else if (this.tracker instanceof EntityPlayer) {
+            this.addRemoveRate = 5; // players
+        } else {
+            this.addRemoveRate = 10; // default
+        }
+        this.addRemoveCooldown = this.tracker.getId() % addRemoveRate;
+        // Nacho end
     }
 
     public boolean equals(Object object) {
@@ -68,6 +92,69 @@ public class EntityTrackerEntry {
         return this.tracker.getId();
     }
 
+    // Nacho start - Async entity tracker
+    public void update() {
+        this.withinNoTrack = this.withinNoTrack();
+        if (--this.addRemoveCooldown <= 0) {
+            this.removeFarPlayers();
+            this.addNearPlayers();
+            this.addRemoveCooldown = this.addRemoveRate;
+        }
+
+        this.track(null);
+    }
+
+    protected void removeFarPlayers() {
+        if (this.withinNoTrack) {
+            toRemove.addAll(this.trackedPlayers);
+            processToRemove();
+            return;
+        }
+
+        for (EntityPlayer entityplayer : trackedPlayers) {
+            double d0 = entityplayer.locX - this.tracker.locX;
+            double d1 = entityplayer.locZ - this.tracker.locZ;
+            int range = this.getRange();
+
+            if (!(d0 >= (-range) && d0 <= range && d1 >= (-range) && d1 <= range) || withinNoTrack()) {
+                toRemove.add(entityplayer);
+            }
+        }
+
+        this.processToRemove();
+    }
+
+    protected void processToRemove() {
+        for (EntityPlayer entityPlayer : toRemove) {
+            entityPlayer.d(this.tracker);
+            this.trackedPlayers.remove(entityPlayer);
+        }
+
+        toRemove.clear();
+    }
+
+    protected void addNearPlayers() {
+        addNearPlayers(false);
+    }
+
+    protected void addNearPlayers(boolean updateCooldown) {
+        if (this.withinNoTrack) {
+            return;
+        }
+        if (updateCooldown) {
+            this.addRemoveCooldown = addRemoveRate;
+        }
+        this.tracker.world.playerMap.forEachNearby(this.tracker.locX, this.tracker.locY, this.tracker.locZ,
+                this.getRange(), false, addNearPlayersConsumer);
+    }
+
+    protected boolean withinNoTrack() {
+        return false; // Titanium - simplify code since it always returned false - maybe will be used in the future so I left this method
+    }
+
+    private final Consumer<EntityPlayer> addNearPlayersConsumer = this::updatePlayer;
+    // Nacho end
+
     public void track(List<EntityHuman> list) {
         this.n = false;
         if (!this.isMoving || this.tracker.e(this.q, this.r, this.s) > 16.0D) {
@@ -76,7 +163,7 @@ public class EntityTrackerEntry {
             this.s = this.tracker.locZ;
             this.isMoving = true;
             this.n = true;
-            this.scanPlayers(list);
+            //this.scanPlayers(list); // Nacho - Async entity tracker
         }
 
         if (this.w != this.tracker.vehicle || this.tracker.vehicle != null && this.m % 60 == 0) {
@@ -100,7 +187,7 @@ public class EntityTrackerEntry {
                     Packet packet = Items.FILLED_MAP.c(itemstack, this.tracker.world, entityplayer);
 
                     if (packet != null) {
-                        entityplayer.playerConnection.sendPacket(packet);
+                        entityplayer.playerConnection.sendPacket(packet); 
                     }
                 }
             }
@@ -154,9 +241,11 @@ public class EntityTrackerEntry {
                         this.y = this.tracker.onGround;
                         this.v = 0;
                         // CraftBukkit start - Refresh list of who can see a player before sending teleport packet
-                        if (this.tracker instanceof EntityPlayer) {
+                        // Nacho start - Async entity tracker
+                        /*if (this.tracker instanceof EntityPlayer) {
                             this.scanPlayers(new java.util.ArrayList(this.tracker.world.players)); // [SportPaper-0203] Fix Teleport Invisibility this.trackedPlayers -> this.tracker.world.players
-                        }
+                        }*/
+                        // Nacho end
                         // CraftBukkit end
                         object = new PacketPlayOutEntityTeleport(this.tracker.getId(), i, j, k, (byte) l, (byte) i1, this.tracker.onGround);
                     }
@@ -191,9 +280,9 @@ public class EntityTrackerEntry {
                                 if (teleportPacket == null) {
                                     teleportPacket = new PacketPlayOutEntityTeleport(this.tracker.getId(), i, j, k, (byte) l, (byte) i1, this.tracker.onGround);
                                 }
-                                viewer.getKey().playerConnection.sendPacket(teleportPacket);
+                                viewer.getKey().playerConnection.sendPacket(teleportPacket); 
                             } else {
-                                viewer.getKey().playerConnection.sendPacket((Packet) object);
+                                viewer.getKey().playerConnection.sendPacket((Packet) object); 
                             }
                         }
                     }
@@ -334,10 +423,12 @@ public class EntityTrackerEntry {
     }
 
     public void updatePlayer(EntityPlayer entityplayer) {
-        org.spigotmc.AsyncCatcher.catchOp( "player tracker update"); // Spigot
+        //org.spigotmc.AsyncCatcher.catchOp( "player tracker update"); // Spigot // Nacho - Async entity tracker
         if (entityplayer != this.tracker) {
+            boolean isPlayerEntityTracked = this.trackedPlayers.contains(entityplayer);
             if (this.c(entityplayer)) {
-                if (!this.trackedPlayers.contains(entityplayer) && (this.e(entityplayer) || this.tracker.attachedToPlayer)) {
+                if (!isPlayerEntityTracked && (this.e(entityplayer) || this.tracker.attachedToPlayer)) {
+                    if (this.tracker instanceof EntityPlayer && withinNoTrack()) return; // Nacho - Async entity tracker
                     // CraftBukkit start - respect vanish API
                     if (this.tracker instanceof EntityPlayer) {
                         Player player = ((EntityPlayer) this.tracker).getBukkitEntity();
@@ -346,20 +437,20 @@ public class EntityTrackerEntry {
                         }
                     }
 
-                    entityplayer.removeQueue.remove(Integer.valueOf(this.tracker.getId()));
+                    //entityplayer.removeQueue.remove(Integer.valueOf(this.tracker.getId())); // Nacho - Async entity tracker
                     // CraftBukkit end
                     this.trackedPlayerMap.put(entityplayer, true); // PaperBukkit
                     Packet packet = this.c();
 
-                    entityplayer.playerConnection.sendPacket(packet);
+                    entityplayer.playerConnection.sendPacket(packet); 
                     if (!this.tracker.getDataWatcher().d()) {
-                        entityplayer.playerConnection.sendPacket(new PacketPlayOutEntityMetadata(this.tracker.getId(), this.tracker.getDataWatcher(), true));
+                        entityplayer.playerConnection.sendPacket(new PacketPlayOutEntityMetadata(this.tracker.getId(), this.tracker.getDataWatcher(), true)); 
                     }
 
                     NBTTagCompound nbttagcompound = this.tracker.getNBTTag();
 
                     if (nbttagcompound != null) {
-                        entityplayer.playerConnection.sendPacket(new PacketPlayOutUpdateEntityNBT(this.tracker.getId(), nbttagcompound));
+                        entityplayer.playerConnection.sendPacket(new PacketPlayOutUpdateEntityNBT(this.tracker.getId(), nbttagcompound)); 
                     }
 
                     if (this.tracker instanceof EntityLiving) {
@@ -373,7 +464,7 @@ public class EntityTrackerEntry {
                         // CraftBukkit end
 
                         if (!collection.isEmpty()) {
-                            entityplayer.playerConnection.sendPacket(new PacketPlayOutUpdateAttributes(this.tracker.getId(), collection));
+                            entityplayer.playerConnection.sendPacket(new PacketPlayOutUpdateAttributes(this.tracker.getId(), collection)); 
                         }
                     }
 
@@ -381,15 +472,15 @@ public class EntityTrackerEntry {
                     this.k = this.tracker.motY;
                     this.l = this.tracker.motZ;
                     if (this.u && !(packet instanceof PacketPlayOutSpawnEntityLiving)) {
-                        entityplayer.playerConnection.sendPacket(new PacketPlayOutEntityVelocity(this.tracker.getId(), this.tracker.motX, this.tracker.motY, this.tracker.motZ));
+                        entityplayer.playerConnection.sendPacket(new PacketPlayOutEntityVelocity(this.tracker.getId(), this.tracker.motX, this.tracker.motY, this.tracker.motZ)); 
                     }
 
                     if (this.tracker.vehicle != null) {
-                        entityplayer.playerConnection.sendPacket(new PacketPlayOutAttachEntity(0, this.tracker, this.tracker.vehicle));
+                        entityplayer.playerConnection.sendPacket(new PacketPlayOutAttachEntity(0, this.tracker, this.tracker.vehicle)); 
                     }
 
                     if (this.tracker instanceof EntityInsentient && ((EntityInsentient) this.tracker).getLeashHolder() != null) {
-                        entityplayer.playerConnection.sendPacket(new PacketPlayOutAttachEntity(1, this.tracker, ((EntityInsentient) this.tracker).getLeashHolder()));
+                        entityplayer.playerConnection.sendPacket(new PacketPlayOutAttachEntity(1, this.tracker, ((EntityInsentient) this.tracker).getLeashHolder())); 
                     }
 
                     if (this.tracker instanceof EntityLiving) {
@@ -397,7 +488,7 @@ public class EntityTrackerEntry {
                             ItemStack itemstack = ((EntityLiving) this.tracker).getEquipment(i);
 
                             if (itemstack != null) {
-                                entityplayer.playerConnection.sendPacket(new PacketPlayOutEntityEquipment(this.tracker.getId(), i, itemstack));
+                                entityplayer.playerConnection.sendPacket(new PacketPlayOutEntityEquipment(this.tracker.getId(), i, itemstack)); 
                             }
                         }
                     }
@@ -406,7 +497,7 @@ public class EntityTrackerEntry {
                         EntityHuman entityhuman = (EntityHuman) this.tracker;
 
                         if (entityhuman.isSleeping()) {
-                            entityplayer.playerConnection.sendPacket(new PacketPlayOutBed(entityhuman, new BlockPosition(this.tracker)));
+                            entityplayer.playerConnection.sendPacket(new PacketPlayOutBed(entityhuman, new BlockPosition(this.tracker))); 
                         }
                     }
 
@@ -418,7 +509,7 @@ public class EntityTrackerEntry {
                            the packet again in a method that is already called for each player. This would create a very serious performance issue
                            with high player and entity counts (each sendPacket call involves waking up the event loop and flushing the network stream).
                            this.broadcast(new PacketPlayOutEntityHeadRotation(this.tracker, (byte) i));*/
-                        entityplayer.playerConnection.sendPacket(new PacketPlayOutEntityHeadRotation(this.tracker, (byte) i));
+                        entityplayer.playerConnection.sendPacket(new PacketPlayOutEntityHeadRotation(this.tracker, (byte) i)); 
                         // CraftBukkit end
                     }
                     // CraftBukkit end
@@ -430,11 +521,11 @@ public class EntityTrackerEntry {
                         while (iterator.hasNext()) {
                             MobEffect mobeffect = (MobEffect) iterator.next();
 
-                            entityplayer.playerConnection.sendPacket(new PacketPlayOutEntityEffect(this.tracker.getId(), mobeffect));
+                            entityplayer.playerConnection.sendPacket(new PacketPlayOutEntityEffect(this.tracker.getId(), mobeffect)); 
                         }
                     }
                 }
-            } else if (this.trackedPlayers.contains(entityplayer)) {
+            } else if (isPlayerEntityTracked) {
                 this.trackedPlayers.remove(entityplayer);
                 entityplayer.d(this.tracker);
             }
@@ -455,12 +546,14 @@ public class EntityTrackerEntry {
         return entityplayer.u().getPlayerChunkMap().a(entityplayer, this.tracker.ae, this.tracker.ag);
     }
 
-    public void scanPlayers(List<EntityHuman> list) {
+    // Nacho start - Async entity tracker
+    /*public void scanPlayers(List<EntityHuman> list) {
         for (int i = 0; i < list.size(); ++i) {
             this.updatePlayer((EntityPlayer) list.get(i));
         }
 
-    }
+    }*/
+    // Nacho end
 
     protected Packet createPacket() { return this.c(); } // IonSpigot - OBFHELPER
 
@@ -574,10 +667,18 @@ public class EntityTrackerEntry {
         }
     }
 
+    // Nacho start - Async entity tracker
+    public int getRange() {
+        if (this.tracker.passenger == null) {
+            return this.b;
+        }
+        return Math.max(this.b, org.spigotmc.TrackingRange.getEntityTrackingRange(this.tracker.passenger, 0));
+    }
+    // Nacho end
+
     public void clear(EntityPlayer entityplayer) {
         org.spigotmc.AsyncCatcher.catchOp( "player tracker clear"); // Spigot
-        if (this.trackedPlayers.contains(entityplayer)) {
-            this.trackedPlayers.remove(entityplayer);
+        if (this.trackedPlayers.remove(entityplayer)) { // Nacho - Micro optimisation
             entityplayer.d(this.tracker);
         }
 
diff --git a/src/main/java/net/minecraft/server/MinecraftServer.java b/src/main/java/net/minecraft/server/MinecraftServer.java
index 7476ece1e4fa58e94132fd8627cd2eef13e3845e..13ac82adf72f02dfcd2b425a2012c00093780587 100644
--- a/src/main/java/net/minecraft/server/MinecraftServer.java
+++ b/src/main/java/net/minecraft/server/MinecraftServer.java
@@ -10,6 +10,7 @@ import com.mojang.authlib.GameProfile;
 import com.mojang.authlib.GameProfileRepository;
 import com.mojang.authlib.minecraft.MinecraftSessionService;
 import com.mojang.authlib.yggdrasil.YggdrasilAuthenticationService;
+import ga.windpvp.windspigot.async.entitytracker.AsyncEntityTracker;
 import net.titanium.tickloop.ReentrantIAsyncHandler;
 import net.titanium.tickloop.TasksPerTick;
 import io.netty.buffer.ByteBuf;
@@ -42,6 +43,7 @@ import java.util.function.BooleanSupplier;
 import java.util.function.Function;
 import javax.imageio.ImageIO;
 import net.titanium.config.TitaniumConfig;
+import net.titanium.util.async.AsyncUtil;
 import org.apache.commons.lang3.Validate;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
@@ -616,7 +618,7 @@ public abstract class MinecraftServer extends ReentrantIAsyncHandler<TasksPerTic
     }
     private static final java.math.BigDecimal TPS_BASE = new java.math.BigDecimal(1E9).multiply(new java.math.BigDecimal(SAMPLE_INTERVAL));
     // PaperSpigot End
- 
+
     public void run() {
         try {
             serverStartTime = getNanos(); // Paper
@@ -1027,7 +1029,6 @@ public abstract class MinecraftServer extends ReentrantIAsyncHandler<TasksPerTic
                     worldserver.a(crashreport);
                     throw new ReportedException(crashreport);
                 }
-
                 this.methodProfiler.b();
                 this.methodProfiler.a("tracker");
                 worldserver.timings.tracker.startTiming(); // Spigot
@@ -1043,7 +1044,13 @@ public abstract class MinecraftServer extends ReentrantIAsyncHandler<TasksPerTic
                 }
                 try {
                     // Tuinity end
-                    worldserver.getTracker().updatePlayers();
+                    // Titanium start
+                    if (worldserver.handleTrackerAsync) {
+                        AsyncUtil.run(worldserver.updateTracker, AsyncEntityTracker.getDispatcher());
+                    } else {
+                        worldserver.getTracker().updatePlayers();
+                    }
+                    // Titanium end
                     // Tuinity start - controlled flush for entity tracker packets
                 } finally {
                     for (NetworkManager networkManager : disabledFlushes) {
diff --git a/src/main/java/net/minecraft/server/PlayerList.java b/src/main/java/net/minecraft/server/PlayerList.java
index b8daeda95f0f7029da9cc62be90959a924c3d7a1..37703b8301117a87ff4f60ea5bf8d5b5358e04b1 100644
--- a/src/main/java/net/minecraft/server/PlayerList.java
+++ b/src/main/java/net/minecraft/server/PlayerList.java
@@ -355,6 +355,7 @@ public abstract class PlayerList {
 
     public void d(EntityPlayer entityplayer) {
         entityplayer.u().getPlayerChunkMap().movePlayer(entityplayer);
+        entityplayer.world.playerMap.move(entityplayer);
     }
 
     public String disconnect(EntityPlayer entityplayer) { // CraftBukkit - return string
diff --git a/src/main/java/net/minecraft/server/World.java b/src/main/java/net/minecraft/server/World.java
index 18df311cafd2ca777a07292a69a75f3259d907bc..3c994004c33458ac43891aaa01dfe32289e8849a 100644
--- a/src/main/java/net/minecraft/server/World.java
+++ b/src/main/java/net/minecraft/server/World.java
@@ -5,6 +5,7 @@ import com.google.common.collect.Lists;
 import com.google.common.collect.Maps;
 import com.google.common.collect.Sets;
 import it.unimi.dsi.fastutil.objects.ObjectArrayList;
+import me.rastrian.dev.PlayerMap;
 import me.suicidalkids.ion.blocks.movement.MovementCache;
 import net.titanium.config.IonWorldConfig;
 import net.titanium.config.PaperWorldConfig;
@@ -146,6 +147,7 @@ public abstract class World implements IBlockAccess {
     private org.spigotmc.TickLimiter entityLimiter;
     private org.spigotmc.TickLimiter tileLimiter;
     private int tileTickPosition;
+    public final PlayerMap playerMap = new PlayerMap(); // Nacho - Async entity tracker
     public ExecutorService lightingExecutor = Executors.newSingleThreadExecutor(new ThreadFactoryBuilder().setNameFormat("PaperSpigot - Lighting Thread").build()); // PaperSpigot - Asynchronous lighting updates
     public final Map<Explosion.CacheKey, Float> explosionDensityCache = new HashMap<Explosion.CacheKey, Float>(); // PaperSpigot - Optimize explosions
 
@@ -1149,6 +1151,7 @@ public abstract class World implements IBlockAccess {
                 EntityHuman entityhuman = (EntityHuman) entity;
 
                 this.players.add(entityhuman);
+                this.playerMap.add((EntityPlayer) entityhuman); // Nacho - Async entity tracker
                 this.everyoneSleeping();
             }
 
@@ -1188,6 +1191,7 @@ public abstract class World implements IBlockAccess {
         if (entity instanceof EntityHuman) {
             this.players.remove(entity);
             this.worldMaps.removeTrackedPlayer((EntityHuman) entity); // FlamePaper - Minetick fix memory leaks
+            this.playerMap.remove((EntityPlayer) entity); // Nacho - Async entity tracker
             // Spigot start
             for ( Object o : worldMaps.c )
             {
@@ -1217,6 +1221,7 @@ public abstract class World implements IBlockAccess {
         if (entity instanceof EntityHuman) {
             this.players.remove(entity);
             this.worldMaps.removeTrackedPlayer((EntityHuman) entity); // FlamePaper - Minetick fix memory leaks
+            this.playerMap.remove((EntityPlayer) entity); // Nacho - Async entity tracker
             this.everyoneSleeping();
         }
 
@@ -2961,11 +2966,14 @@ public abstract class World implements IBlockAccess {
     }
 
     public EntityHuman findNearbyPlayer(double d0, double d1, double d2, double d3) {
+        if (0 <= d3 && d3 <= 64) { return this.playerMap.getNearestPlayer(d0, d1, d2, d3); } // Nacho - Async entity tracker
         double d4 = -1.0D;
         EntityHuman entityhuman = null;
 
-        for (int i = 0; i < this.players.size(); ++i) {
-            EntityHuman entityhuman1 = (EntityHuman) this.players.get(i);
+        // Nacho start - Async entity tracker
+        /*for (int i = 0; i < this.players.size(); ++i) {
+            EntityHuman entityhuman1 = (EntityHuman) this.players.get(i);*/
+        for (EntityHuman entityhuman1 : a(EntityHuman.class, AxisAlignedBB.a(d0 - d3, d1 - d3, d2 - d3, d0 + d3, d1 + d3, d2 + d3))) { // Nacho end
             // CraftBukkit start - Fixed an NPE
             if (entityhuman1 == null || entityhuman1.dead) {
                 continue;
@@ -3007,6 +3015,7 @@ public abstract class World implements IBlockAccess {
     }
 
     public EntityHuman findNearbyPlayerWhoAffectsSpawning(double d0, double d1, double d2, double d3) {
+        if (0 <= d3 && d3 <= 64.0) { return this.playerMap.getNearbyPlayer(d0, d1, d2, d3, true); } // Nacho - Async entity tracker
         double d4 = -1.0D;
         EntityHuman entityhuman = null;
 
diff --git a/src/main/java/net/minecraft/server/WorldManager.java b/src/main/java/net/minecraft/server/WorldManager.java
index c3bda441dfa2f59a0570d578676a6d3e9765fdb6..e37a7ef874977b2fd85fee9bf5b61e4de0e964a5 100644
--- a/src/main/java/net/minecraft/server/WorldManager.java
+++ b/src/main/java/net/minecraft/server/WorldManager.java
@@ -25,12 +25,18 @@ public class WorldManager implements IWorldAccess {
 
     public void a(String s, double d0, double d1, double d2, float f, float f1) {
         // CraftBukkit - this.world.dimension
-        this.a.getPlayerList().sendPacketNearby(d0, d1, d2, f > 1.0F ? (double) (16.0F * f) : 16.0D, this.world.dimension, new PacketPlayOutNamedSoundEffect(s, d0, d1, d2, f, f1));
+        // Nacho start - Async entity tracker
+        //this.a.getPlayerList().sendPacketNearby(d0, d1, d2, f > 1.0F ? (double) (16.0F * f) : 16.0D, this.world.dimension, new PacketPlayOutNamedSoundEffect(s, d0, d1, d2, f, f1));
+        this.world.playerMap.sendPacketNearby(null, d0, d1, d2, f > 1.0F ? (double) (16.0F * f) : 16.0D, new PacketPlayOutNamedSoundEffect(s, d0, d1, d2, f, f1), false);
+        // Nacho end
     }
 
     public void a(EntityHuman entityhuman, String s, double d0, double d1, double d2, float f, float f1) {
         // CraftBukkit - this.world.dimension, // Paper - this.world.dimension -> this.world
-        this.a.getPlayerList().sendPacketNearby(entityhuman, d0, d1, d2, f > 1.0F ? (double) (16.0F * f) : 16.0D, this.world, new PacketPlayOutNamedSoundEffect(s, d0, d1, d2, f, f1));
+        // Nacho start - Async entity tracker
+        //this.a.getPlayerList().sendPacketNearby(entityhuman, d0, d1, d2, f > 1.0F ? (double) (16.0F * f) : 16.0D, this.world, new PacketPlayOutNamedSoundEffect(s, d0, d1, d2, f, f1));
+        this.world.playerMap.sendPacketNearby((EntityPlayer) entityhuman, d0, d1, d2, f > 1.0F ? (double) (16.0F * f) : 16.0D, new PacketPlayOutNamedSoundEffect(s, d0, d1, d2, f, f1), false);
+        // Nacho end
     }
 
     public void a(int i, int j, int k, int l, int i1, int j1) {}
@@ -45,7 +51,10 @@ public class WorldManager implements IWorldAccess {
 
     public void a(EntityHuman entityhuman, int i, BlockPosition blockposition, int j) {
         // CraftBukkit - this.world.dimension
-        this.a.getPlayerList().sendPacketNearby(entityhuman, (double) blockposition.getX(), (double) blockposition.getY(), (double) blockposition.getZ(), 64.0D, this.world, new PacketPlayOutWorldEvent(i, blockposition, j, false));
+        // Nacho start - Async entity tracker
+        //this.a.getPlayerList().sendPacketNearby(entityhuman, (double) blockposition.getX(), (double) blockposition.getY(), (double) blockposition.getZ(), 64.0D, this.world, new PacketPlayOutWorldEvent(i, blockposition, j, false));
+        this.world.playerMap.sendPacketNearby((EntityPlayer) entityhuman, blockposition.getX(), blockposition.getY(), blockposition.getZ(), 64.0D, new PacketPlayOutWorldEvent(i, blockposition, j, false), false);
+        // Nacho end
     }
 
     public void a(int i, BlockPosition blockposition, int j) {
@@ -80,10 +89,11 @@ public class WorldManager implements IWorldAccess {
                     continue;
                 }
                 // CraftBukkit end
-
-                if (d0 * d0 + d1 * d1 + d2 * d2 < 1024.0D) {
-                    entityplayer.playerConnection.sendPacket(new PacketPlayOutBlockBreakAnimation(i, blockposition, j));
-                }
+                // Nacho start - Async entity tracker
+                //if (d0 * d0 + d1 * d1 + d2 * d2 < 1024.0D) {
+                    this.world.playerMap.sendPacketNearby(entityplayer, blockposition.getX(), blockposition.getY(), blockposition.getZ(), 32.0D, new PacketPlayOutBlockBreakAnimation(i, blockposition, j), false);
+                //}
+                // Nacho end
             }
         }
 
diff --git a/src/main/java/net/minecraft/server/WorldServer.java b/src/main/java/net/minecraft/server/WorldServer.java
index ff8ac6c5270ce40a21c4d9519a09c5ede68b1072..b504a01f9ada3104604e79a661b6d56247485892 100644
--- a/src/main/java/net/minecraft/server/WorldServer.java
+++ b/src/main/java/net/minecraft/server/WorldServer.java
@@ -5,7 +5,9 @@ import com.google.common.collect.Lists;
 import com.google.common.collect.Maps;
 import com.google.common.collect.Sets;
 import com.google.common.util.concurrent.ListenableFuture;
+import ga.windpvp.windspigot.async.entitytracker.AsyncEntityTracker;
 import java.util.ArrayList;
+import java.util.Collection;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
@@ -52,6 +54,10 @@ public class WorldServer extends World implements IAsyncTaskHandler {
     private static final List<StructurePieceTreasure> U = Lists.newArrayList(new StructurePieceTreasure[] { new StructurePieceTreasure(Items.STICK, 0, 1, 3, 10), new StructurePieceTreasure(Item.getItemOf(Blocks.PLANKS), 0, 1, 3, 10), new StructurePieceTreasure(Item.getItemOf(Blocks.LOG), 0, 1, 3, 10), new StructurePieceTreasure(Items.STONE_AXE, 0, 1, 1, 3), new StructurePieceTreasure(Items.WOODEN_AXE, 0, 1, 1, 5), new StructurePieceTreasure(Items.STONE_PICKAXE, 0, 1, 1, 3), new StructurePieceTreasure(Items.WOODEN_PICKAXE, 0, 1, 1, 5), new StructurePieceTreasure(Items.APPLE, 0, 2, 3, 5), new StructurePieceTreasure(Items.BREAD, 0, 2, 3, 3), new StructurePieceTreasure(Item.getItemOf(Blocks.LOG2), 0, 1, 3, 10)});
     private List<NextTickListEntry> V = Lists.newArrayList();
     public boolean hasPhysicsEvent = true; // Paper
+    // Titanium start
+    public final boolean handleTrackerAsync = TitaniumConfig.get().entityTracker.async.enabled;
+    public final Runnable updateTracker = () -> this.tracker.updatePlayers();
+    // Titanium end
 
     // CraftBukkit start
     public final int dimension;
@@ -64,7 +70,13 @@ public class WorldServer extends World implements IAsyncTaskHandler {
         worlddata.world = this;
         // CraftBukkit end
         this.server = minecraftserver;
-        this.tracker = new EntityTracker(this);
+        // Nacho start - Async entity tracker
+        if (this.handleTrackerAsync) {
+            this.tracker = new AsyncEntityTracker(this);
+        } else {
+            this.tracker = new EntityTracker(this);
+        }
+        // Nacho end
         this.manager = new PlayerChunkMap(this, spigotConfigTitanium.viewDistance); // Spigot
         this.worldProvider.a(this);
         this.chunkProvider = this.k();
diff --git a/src/main/java/net/titanium/config/TitaniumConfig.java b/src/main/java/net/titanium/config/TitaniumConfig.java
index 6f41c04483bda78fc8df2a10f6622511fcb10ab0..1b461c79a1334c8e2fec89b32c3b1c0f654be83e 100644
--- a/src/main/java/net/titanium/config/TitaniumConfig.java
+++ b/src/main/java/net/titanium/config/TitaniumConfig.java
@@ -144,6 +144,7 @@ TitaniumConfig extends TitaniumConfigSection {
         public IO io = new IO();
 
         public static class IO extends TitaniumConfigSection {
+
             @Comment("The amount of threads to use for chunk loading (start value).")
             public int baseThreads = 2; // PaperSpigot - Bumped value
 
@@ -151,6 +152,7 @@ TitaniumConfig extends TitaniumConfigSection {
             @Comment("This values represents how many players are needed to create a new thread.")
             @Comment("For eg. base-threads is 2, on server is 100 players, when one more joins server new thread will be created and so on.")
             public int playersPerThread = 50;
+
         }
 
     }
@@ -174,6 +176,26 @@ TitaniumConfig extends TitaniumConfigSection {
 
     }
 
+    public EntityTracker entityTracker = new EntityTracker();
+
+    public static class EntityTracker extends TitaniumConfigSection {
+
+        public Async async = new Async();
+
+        public static class Async extends TitaniumConfigSection {
+
+            @Comment("Whether to use asynchronous entity tracking.")
+            @Comment("Enabling this could be good idea since it can have good impact on performance.")
+            @Comment("Disable it if something doesn't work properly (for eg. anticheat plugin).")
+            public boolean enabled = false;
+
+            @Comment("How many threads to use for entity tracking.")
+            public int threads = 4;
+
+        }
+
+    }
+
     @Comment("When this option is enabled, the server will create a directory `legacy_configs` with files like bukkit.yml, spigot.yml etc.")
     @Comment("Changing option there will not affect the server, it's only mirror of this file.")
     @Comment("Enable this option only if some of your plugins are not compatible with the new configs.")
diff --git a/src/main/java/net/titanium/util/IndexedLinkedSet.java b/src/main/java/net/titanium/util/IndexedLinkedSet.java
new file mode 100644
index 0000000000000000000000000000000000000000..7c36c1fd2e3678c7bcdcf1a066ab1ced040b0346
--- /dev/null
+++ b/src/main/java/net/titanium/util/IndexedLinkedSet.java
@@ -0,0 +1,96 @@
+package net.titanium.util;
+
+import com.google.common.collect.Lists;
+import java.util.Collection;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Set;
+
+public final class IndexedLinkedSet<E> implements Set<E> {
+
+    private final List<E> list = Lists.newCopyOnWriteArrayList();
+
+    @Override
+    public boolean add(E e) {
+        if (this.contains(e)) {
+            return false;
+        }
+        return this.list.add(e);
+    }
+
+    @Override
+    public boolean remove(Object o) {
+        return this.list.remove(o);
+    }
+
+    @Override
+    public boolean containsAll(Collection<?> c) {
+        return new HashSet<>(this.list).containsAll(c);
+    }
+
+    @Override
+    public void clear() {
+        this.list.clear();
+    }
+
+    public E get(int index) {
+        return this.list.get(index);
+    }
+
+    @Override
+    public boolean removeAll(Collection<?> c) {
+        return this.list.removeAll(c);
+    }
+
+    @Override
+    public boolean retainAll(Collection<?> c) {
+        return this.list.retainAll(c);
+    }
+
+    @Override
+    public boolean addAll(Collection<? extends E> c) {
+        boolean modified = false;
+        for (E e : c) {
+            if (this.add(e)) {
+                modified = true;
+            }
+        }
+        return modified;
+    }
+
+    @Override
+    public int size() {
+        return this.list.size();
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return this.list.isEmpty();
+    }
+
+    @Override
+    public boolean contains(Object o) {
+        return this.list.contains(o);
+    }
+
+    @Override
+    public Iterator<E> iterator() {
+        return this.list.iterator();
+    }
+
+    @Override
+    public Object[] toArray() {
+        return this.list.toArray();
+    }
+
+    @Override
+    public <T> T[] toArray(T[] a) {
+        return this.list.toArray(a);
+    }
+
+    public int indexOf(Object o) {
+        return this.list.indexOf(o);
+    }
+
+}
\ No newline at end of file
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftServer.java b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
index 5e6fc10726aed332b2a4560df9defbc3bde38a2d..55d5c1d617f221ddb502b608587c8c024f9493a4 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftServer.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
@@ -7,6 +7,7 @@ import com.google.common.collect.Lists;
 import com.google.common.collect.MapMaker;
 import com.mojang.authlib.GameProfile;
 import eu.okaeri.configs.OkaeriConfig;
+import ga.windpvp.windspigot.async.entitytracker.AsyncEntityTracker;
 import java.awt.image.BufferedImage;
 import java.io.File;
 import java.io.FileInputStream;
@@ -992,7 +993,13 @@ public final class CraftServer implements Server {
 
         internal.scoreboard = getScoreboardManager().getMainScoreboard().getHandle();
 
-        internal.tracker = new EntityTracker(internal);
+        // Nacho start - Async entity tracker
+        if (TitaniumConfig.get().entityTracker.async.enabled) {
+            internal.tracker = new AsyncEntityTracker(internal);
+        } else {
+            internal.tracker = new EntityTracker(internal);
+        }
+        // Nacho end
         internal.addIWorldAccess(new WorldManager(console, internal));
         internal.worldData.setDifficulty(EnumDifficulty.EASY);
         internal.setSpawnFlags(true, true);
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
index edad1260e98c95c36c33ea97c4e087539414197b..58846a42b2f71c4777d050d668ef6bb34e51e923 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
@@ -2,6 +2,7 @@ package org.bukkit.craftbukkit.entity;
 
 import com.google.common.base.Preconditions;
 import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Sets;
 import com.mojang.authlib.GameProfile;
 import io.netty.buffer.Unpooled;
 
@@ -75,7 +76,7 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
     private boolean hasPlayedBefore = false;
     private final ConversationTracker conversationTracker = new ConversationTracker();
     private final Set<String> channels = new HashSet<String>();
-    private final Set<UUID> hiddenPlayers = new HashSet<UUID>();
+    private final Set<UUID> hiddenPlayers = Sets.newConcurrentHashSet(); // WindSpigot - concurrent collection
     private int hash = 0;
     private double health = 20;
     private boolean scaledHealth = false;
diff --git a/src/main/java/org/spigotmc/TrackingRange.java b/src/main/java/org/spigotmc/TrackingRange.java
index f5e38264a91b265b347082b9c462309b3c69b644..bfe635e0b162bb1aa70ba0fe1e30edec87988d41 100644
--- a/src/main/java/org/spigotmc/TrackingRange.java
+++ b/src/main/java/org/spigotmc/TrackingRange.java
@@ -1,12 +1,15 @@
 package org.spigotmc;
 
 import net.minecraft.server.Entity;
+import net.minecraft.server.EntityArrow;
 import net.minecraft.server.EntityExperienceOrb;
+import net.minecraft.server.EntityFishingHook;
 import net.minecraft.server.EntityGhast;
 import net.minecraft.server.EntityItem;
 import net.minecraft.server.EntityItemFrame;
 import net.minecraft.server.EntityPainting;
 import net.minecraft.server.EntityPlayer;
+import net.minecraft.server.EntityProjectile;
 import net.titanium.config.SpigotWorldConfig;
 
 public class TrackingRange
@@ -24,7 +27,7 @@ public class TrackingRange
     {
         SpigotWorldConfig config = entity.world.spigotConfigTitanium;
         SpigotWorldConfig.EntityTrackingRange trackingConfig = config.entityTrackingRange;
-        if ( entity instanceof EntityPlayer )
+        if ( entity instanceof EntityPlayer || entity instanceof EntityArrow || entity instanceof EntityProjectile || entity instanceof EntityFishingHook) // Nacho - Async entity tracker
         {
             return trackingConfig.players;
         }  else if ( entity.activationType == 1 )
