From 02a10561b56cf2b60ba678b0e266eaad5772ec46 Mon Sep 17 00:00:00 2001
From: Rastrian <me@rastrian.dev>
Date: Fri, 17 Jun 2022 01:57:00 +0200
Subject: [PATCH] Async Entity Tracker

Co-authored-by: windcolor-dev <teaglehao@gmail.com>
Co-authored-by: Peridot <peridot491@protonmail.com>

diff --git a/build.gradle b/build.gradle
index 44d4bd77b..4a38e8f63 100644
--- a/build.gradle
+++ b/build.gradle
@@ -31,7 +31,8 @@ dependencies {
     // PandaSpigot end
     implementation 'com.velocitypowered:velocity-native:1.1.9' // Nacho - Use Velocity natives & compression // Titanium - updated velocity-native to 1.1.9
     implementation 'net.openhft:affinity:3.21ea83' // WindSpigot - Thread affinity
-    implementation 'com.eatthepath:fast-uuid:0.2.0' // Nacho - Use jchambers' FAST UUID methods
+    implementation 'com.eatthepath:fast-uuid:0.2.0' // Nacho - Use jchambers' FAST UUID method
+    implementation 'com.github.matejtymes:javafixes:1.3.6.1' // WindSpigot
     // Titanium libraries end
 
     testImplementation 'junit:junit:4.13.2' // Titanium - Updated junit to 4.13.2
diff --git a/src/main/java/ga/windpvp/windspigot/async/AsyncUtil.java b/src/main/java/ga/windpvp/windspigot/async/AsyncUtil.java
index b1143e247..8bbd109e1 100644
--- a/src/main/java/ga/windpvp/windspigot/async/AsyncUtil.java
+++ b/src/main/java/ga/windpvp/windspigot/async/AsyncUtil.java
@@ -2,6 +2,7 @@ package ga.windpvp.windspigot.async;
 
 import java.util.concurrent.Executor;
 import java.util.concurrent.ForkJoinPool;
+import java.util.function.Supplier;
 import net.minecraft.server.MinecraftServer;
 
 public class AsyncUtil {
@@ -39,5 +40,36 @@ public class AsyncUtil {
 		MinecraftServer.getServer().priorityProcessQueue.add(runnable);
 	}
 
+	/**
+	 * Runs a given task if it is synchronized on an object
+	 * @param monitor The object to check for locking
+	 * @param runnable The task to run
+	 */
+	@SuppressWarnings("SynchronizationOnLocalVariableOrMethodParameter")
+	public static void runSynchronized(Object monitor, Runnable runnable) {
+		if (Thread.holdsLock(monitor) ) {
+			runnable.run();
+		} else {
+			synchronized (monitor) {
+				runnable.run();
+			}
+		}
+	}
+
+	/**
+	 * Runs a given task if it is synchronized on an object
+	 * @param monitor The object to check for locking
+	 * @param supplier The task to run
+	 */
+	@SuppressWarnings("SynchronizationOnLocalVariableOrMethodParameter")
+	public static <T> T runSynchronized(Object monitor, Supplier<T> supplier) {
+		if (Thread.holdsLock(monitor) ) {
+			return supplier.get();
+		} else {
+			synchronized (monitor) {
+				return supplier.get();
+			}
+		}
+	}
 
 }
diff --git a/src/main/java/ga/windpvp/windspigot/async/ResettableLatch.java b/src/main/java/ga/windpvp/windspigot/async/ResettableLatch.java
new file mode 100644
index 000000000..ab41c6a7e
--- /dev/null
+++ b/src/main/java/ga/windpvp/windspigot/async/ResettableLatch.java
@@ -0,0 +1,48 @@
+package ga.windpvp.windspigot.async;
+
+import javafixes.concurrency.ReusableCountLatch;
+
+public class ResettableLatch extends ReusableCountLatch {
+
+	private int initValue;
+
+	public ResettableLatch() {
+		this(0);
+	}
+
+	public ResettableLatch(int initialCount) {
+		super(initialCount);
+		this.initValue = initialCount;
+	}
+
+	/*
+	 * Resets this latch to its value when constructed
+	 */
+	public void reset() {
+		reset(initValue);
+	}
+	
+	/*
+	 * Resets this latch to a value
+	 */
+	public void reset(int count) {
+		
+		if (getCount() > count) {
+
+			while (getCount() > count) {
+				// Decrease the thread count of the latch if it is too high
+				decrement();
+			}
+
+		} else if (getCount() < count) {
+
+			while (getCount() < count) {
+				// Increase the thread count of the latch if it is too low
+				increment();
+			}
+
+		}
+		
+	}
+
+}
diff --git a/src/main/java/ga/windpvp/windspigot/async/entitytracker/AsyncEntityTracker.java b/src/main/java/ga/windpvp/windspigot/async/entitytracker/AsyncEntityTracker.java
new file mode 100644
index 000000000..8f291fe84
--- /dev/null
+++ b/src/main/java/ga/windpvp/windspigot/async/entitytracker/AsyncEntityTracker.java
@@ -0,0 +1,57 @@
+package ga.windpvp.windspigot.async.entitytracker;
+
+import com.google.common.collect.Lists;
+import com.google.common.util.concurrent.ThreadFactoryBuilder;
+import ga.windpvp.windspigot.async.AsyncUtil;
+import ga.windpvp.windspigot.async.ResettableLatch;
+import java.util.List;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import net.minecraft.server.EntityTracker;
+import net.minecraft.server.NetworkManager;
+import net.minecraft.server.WorldServer;
+import net.titanium.config.TitaniumConfig;
+
+public class AsyncEntityTracker extends EntityTracker {
+
+    private static final ExecutorService trackingThreadExecutor = Executors.newCachedThreadPool(new ThreadFactoryBuilder().setNameFormat("WindSpigot Entity Tracker Thread").build());
+    private static final List<NetworkManager> disabledFlushes = Lists.newArrayList();
+
+    private final ResettableLatch latch = new ResettableLatch(TitaniumConfig.get().entityTracker.async.threads);
+
+    public AsyncEntityTracker(WorldServer worldserver) {
+        super(worldserver);
+    }
+
+    @Override
+    public void updatePlayers() {
+        int offset = 0;
+
+        for (int i = 1; i <= TitaniumConfig.get().entityTracker.async.threads; i++) {
+            final int finalOffset = offset++;
+
+            AsyncUtil.run(() -> {
+                for (int index = finalOffset; index < c.size(); index += TitaniumConfig.get().entityTracker.async.threads) {
+                    c.get(index).update();
+                }
+                latch.decrement();
+            }, trackingThreadExecutor);
+
+        }
+        try {
+            latch.waitTillZero();
+            latch.reset();
+        } catch (InterruptedException e) {
+            e.printStackTrace();
+        }
+    }
+
+    public ResettableLatch getLatch() {
+        return latch;
+    }
+
+    public static ExecutorService getExecutor() {
+        return trackingThreadExecutor;
+    }
+
+}
diff --git a/src/main/java/me/rastrian/dev/PlayerMap.java b/src/main/java/me/rastrian/dev/PlayerMap.java
new file mode 100644
index 000000000..835eeabef
--- /dev/null
+++ b/src/main/java/me/rastrian/dev/PlayerMap.java
@@ -0,0 +1,206 @@
+package me.rastrian.dev;
+
+import it.unimi.dsi.fastutil.longs.Long2ObjectArrayMap;
+import it.unimi.dsi.fastutil.longs.Long2ObjectMap;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.function.Consumer;
+import net.minecraft.server.EntityPlayer;
+import net.minecraft.server.MathHelper;
+import net.minecraft.server.Packet;
+
+public class PlayerMap {
+
+    private static final int CHUNK_BITS = 5;
+    private final Long2ObjectMap<List<EntityPlayer>> map = new Long2ObjectArrayMap<>();
+
+    private static long xzToKey(long x, long z) {
+        return (x << 32) + z - Integer.MIN_VALUE;
+    }
+
+    public synchronized void add(EntityPlayer player) {
+        int x = MathHelper.floor(player.locX) >> CHUNK_BITS;
+        int z = MathHelper.floor(player.locZ) >> CHUNK_BITS;
+        long key = xzToKey(x, z);
+        List<EntityPlayer> list = map.get(key);
+        if (list == null) {
+            list = new ArrayList<>();
+            map.put(key, list);
+        }
+        list.add(player);
+        player.playerMapX = x;
+        player.playerMapZ = z;
+    }
+
+    public synchronized void move(EntityPlayer player) {
+        int x = MathHelper.floor(player.locX) >> CHUNK_BITS;
+        int z = MathHelper.floor(player.locZ) >> CHUNK_BITS;
+
+        // did we move?
+        if (x == player.playerMapX && z == player.playerMapZ) {
+            return;
+        }
+
+        // do remove
+        long key = xzToKey(player.playerMapX, player.playerMapZ);
+        List<EntityPlayer> list = map.get(key);
+        list.remove(player);
+        if (list.isEmpty()) {
+            map.remove(key);
+        }
+
+        // do add
+        key = xzToKey(x, z);
+        list = map.get(key);
+        if (list == null) {
+            list = new ArrayList<>();
+            map.put(key, list);
+        }
+        list.add(player);
+        player.playerMapX = x;
+        player.playerMapZ = z;
+    }
+
+    public synchronized void remove(EntityPlayer player) {
+        long key = xzToKey(player.playerMapX, player.playerMapZ);
+        List<EntityPlayer> list = map.get(key);
+        if (list == null) {
+            // player has not yet been added to this playermap, this happens when
+            // teleporting to another world during PlayerJoinEvent
+            return;
+        }
+        list.remove(player);
+        if (list.isEmpty()) {
+            map.remove(key);
+        }
+    }
+
+    public synchronized void forEachNearby(double x, double y, double z, double distance, boolean useRadius, Consumer<EntityPlayer> function) {
+
+        int chunkXMax = MathHelper.floor(x + distance) >> CHUNK_BITS;
+        int chunkZMax = MathHelper.floor(z + distance) >> CHUNK_BITS;
+
+        for (int chunkX = MathHelper.floor(x - distance) >> CHUNK_BITS; chunkX <= chunkXMax; chunkX++) {
+            for (int chunkZ = MathHelper.floor(z - distance) >> CHUNK_BITS; chunkZ <= chunkZMax; chunkZ++) {
+                List<EntityPlayer> players = map.get(xzToKey(chunkX, chunkZ));
+                if (players != null) {
+                    for (EntityPlayer player : players) {
+                        if (!useRadius || player.e(x, y, z) < distance * distance) {
+                            function.accept(player);
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+    public synchronized EntityPlayer getNearestPlayer(double x, double y, double z, double distance) {
+        double bestDistanceSqrd = -1.0;
+        EntityPlayer bestPlayer = null;
+
+        int chunkXMax = MathHelper.floor(x + distance) >> CHUNK_BITS;
+        int chunkZMax = MathHelper.floor(z + distance) >> CHUNK_BITS;
+
+        for (int chunkX = MathHelper.floor(x - distance) >> CHUNK_BITS; chunkX <= chunkXMax; chunkX++) {
+            for (int chunkZ = MathHelper.floor(z - distance) >> CHUNK_BITS; chunkZ <= chunkZMax; chunkZ++) {
+                List<EntityPlayer> players = map.get(xzToKey(chunkX, chunkZ));
+                if (players != null) {
+                    for (EntityPlayer player : players) {
+                        double playerDistSqrd = player.e(x, y, z);
+                        if (playerDistSqrd < distance * distance
+                                && (bestDistanceSqrd == -1.0 || playerDistSqrd < bestDistanceSqrd)) {
+                            bestDistanceSqrd = playerDistSqrd;
+                            bestPlayer = player;
+                        }
+                    }
+                }
+            }
+        }
+        return bestPlayer;
+    }
+
+    public synchronized boolean isPlayerNearby(double x, double y, double z, double distance, boolean respectSpawningApi) {
+
+        int chunkXMax = MathHelper.floor(x + distance) >> CHUNK_BITS;
+        int chunkZMax = MathHelper.floor(z + distance) >> CHUNK_BITS;
+
+        for (int chunkX = MathHelper.floor(x - distance) >> CHUNK_BITS; chunkX <= chunkXMax; chunkX++) {
+            for (int chunkZ = MathHelper.floor(z - distance) >> CHUNK_BITS; chunkZ <= chunkZMax; chunkZ++) {
+                List<EntityPlayer> players = map.get(xzToKey(chunkX, chunkZ));
+                if (players != null) {
+                    for (EntityPlayer player : players) {
+                        if (player != null && !player.dead && (!respectSpawningApi || player.affectsSpawning)) {
+                            double playerDistSqrd = player.e(x, y, z);
+                            if (playerDistSqrd < distance * distance) {
+                                return true;
+                            }
+                        }
+                    }
+                }
+            }
+        }
+        return false;
+    }
+
+    public synchronized EntityPlayer getNearbyPlayer(double x, double y, double z, double distance, boolean respectSpawningApi) {
+        double bestDistanceSqrd = -1.0;
+        EntityPlayer bestPlayer = null;
+
+        int chunkXMax = MathHelper.floor(x + distance) >> CHUNK_BITS;
+        int chunkZMax = MathHelper.floor(z + distance) >> CHUNK_BITS;
+
+        for (int chunkX = MathHelper.floor(x - distance) >> CHUNK_BITS; chunkX <= chunkXMax; chunkX++) {
+            for (int chunkZ = MathHelper.floor(z - distance) >> CHUNK_BITS; chunkZ <= chunkZMax; chunkZ++) {
+                List<EntityPlayer> players = map.get(xzToKey(chunkX, chunkZ));
+                if (players != null) {
+                    for (EntityPlayer player : players) {
+                        if (player != null && !player.dead && (!respectSpawningApi || player.affectsSpawning)) {
+                            double playerDistSqrd = player.e(x, y, z);
+                            if (playerDistSqrd < distance * distance
+                                    && (bestDistanceSqrd == -1.0 || playerDistSqrd < bestDistanceSqrd)) {
+                                bestDistanceSqrd = playerDistSqrd;
+                                bestPlayer = player;
+                            }
+                        }
+                    }
+                }
+            }
+        }
+
+        return bestPlayer;
+    }
+
+    public synchronized void sendPacketNearby(EntityPlayer source, double x, double y, double z, double distance, Packet<?> packet, boolean self) {
+
+        double distanceSqrd = distance * distance;
+        int chunkXMax = MathHelper.floor(x + distance) >> CHUNK_BITS;
+        int chunkZMax = MathHelper.floor(z + distance) >> CHUNK_BITS;
+
+        for (int chunkX = MathHelper.floor(x - distance) >> CHUNK_BITS; chunkX <= chunkXMax; chunkX++) {
+            for (int chunkZ = MathHelper.floor(z - distance) >> CHUNK_BITS; chunkZ <= chunkZMax; chunkZ++) {
+                List<EntityPlayer> players = map.get(xzToKey(chunkX, chunkZ));
+                if (players != null) {
+                    for (EntityPlayer player : players) {
+                        // don't send self
+                        if (!self) {
+                            if (player == source) {
+                                continue;
+                            }
+                        }
+
+                        // bukkit visibility api
+                        if (source != null && !player.getBukkitEntity().canSee(source.getBukkitEntity())) {
+                            continue;
+                        }
+
+                        double playerDistSqrd = player.e(x, y, z);
+                        if (playerDistSqrd < distanceSqrd) {
+                            player.playerConnection.sendPacket(packet);
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+}
\ No newline at end of file
diff --git a/src/main/java/me/rastrian/dev/utils/IndexedLinkedHashSet.java b/src/main/java/me/rastrian/dev/utils/IndexedLinkedHashSet.java
new file mode 100644
index 000000000..5e89ec430
--- /dev/null
+++ b/src/main/java/me/rastrian/dev/utils/IndexedLinkedHashSet.java
@@ -0,0 +1,99 @@
+package me.rastrian.dev.utils;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.Set;
+
+public final class IndexedLinkedHashSet<E> implements Set<E> {
+
+    private final ArrayList<E> list = new ArrayList<>();
+    private final HashSet<E> set = new HashSet<>();
+
+    public boolean add(E e) {
+        if (set.add(e)) {
+            return list.add(e);
+        }
+        return false;
+    }
+
+    public boolean remove(Object o) {
+        if (set.remove(o)) {
+            return list.remove(o);
+        }
+        return false;
+    }
+
+    @Override
+    public boolean containsAll(Collection<?> c) {
+        return set.containsAll(c);
+    }
+
+    public void clear() {
+        set.clear();
+        list.clear();
+    }
+
+    public E get(int index) {
+        return list.get(index);
+    }
+
+    public boolean removeAll(Collection<?> c) {
+        if (set.removeAll(c)) {
+            return list.removeAll(c);
+        }
+        return true;
+    }
+
+    public boolean retainAll(Collection<?> c) {
+        if (set.retainAll(c)) {
+            return list.retainAll(c);
+        }
+        return false;
+    }
+
+    public boolean addAll(Collection<? extends E> c) {
+        boolean modified = false;
+        for (E e : c) {
+            if (add(e)) {
+                modified = true;
+            }
+        }
+        return modified;
+    }
+
+    @Override
+    public int size() {
+        return set.size();
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return set.isEmpty();
+    }
+
+    @Override
+    public boolean contains(Object o) {
+        return set.contains(o);
+    }
+
+    @Override
+    public Iterator<E> iterator() {
+        return list.iterator();
+    }
+
+    @Override
+    public Object[] toArray() {
+        return list.toArray();
+    }
+
+    @Override
+    public <T> T[] toArray(T[] a) {
+        return list.toArray(a);
+    }
+
+    public int indexOf(Object o) {
+        return list.indexOf(o);
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/me/suicidalkids/ion/visuals/CannonTrackerEntry.java b/src/main/java/me/suicidalkids/ion/visuals/CannonTrackerEntry.java
index d37dc2909..32e5a1945 100644
--- a/src/main/java/me/suicidalkids/ion/visuals/CannonTrackerEntry.java
+++ b/src/main/java/me/suicidalkids/ion/visuals/CannonTrackerEntry.java
@@ -1,5 +1,6 @@
 package me.suicidalkids.ion.visuals;
 
+import java.util.ArrayList;
 import net.minecraft.server.*;
 
 import java.util.List;
@@ -20,8 +21,8 @@ public class CannonTrackerEntry extends EntityTrackerEntry {
     private double updateY;
     private double updateZ;
 
-    public CannonTrackerEntry(Entity entity, int i, int j, boolean flag) {
-        super(entity, i, j, flag);
+    public CannonTrackerEntry(EntityTracker entityTracker, Entity entity, int i, int j, boolean flag) {
+        super(entityTracker, entity, i, j, flag);
         this.movingX = entity.motX != 0.0;
         this.movingY = true;
         this.movingZ = entity.motZ != 0.0;
@@ -43,7 +44,7 @@ public class CannonTrackerEntry extends EntityTrackerEntry {
 
         // This entity has moved 4 blocks since the last update, search for players
         if (this.tracker.e(updateX, updateY, updateZ) > 16.0D) {
-            this.scanPlayers(list);
+            //this.scanPlayers(list); // Nacho - Async entity tracker
             this.updateX = this.tracker.locX;
             this.updateY = this.tracker.locY;
             this.updateZ = this.tracker.locZ;
@@ -80,13 +81,15 @@ public class CannonTrackerEntry extends EntityTrackerEntry {
     public void updatePlayer(EntityPlayer entityplayer) {
         // Check configurable distance as a cube then visible distance.
         if (this.c(entityplayer) && this.tracker.h(entityplayer) < 4096.0D) {
+            if (this.tracker instanceof EntityPlayer && withinNoTrack()) return; // Nacho - Async entity tracker
             if (this.trackedPlayers.contains(entityplayer) || (!this.e(entityplayer) && !this.tracker.attachedToPlayer)) {
                 return;
             }
 
-            entityplayer.removeQueue.remove(Integer.valueOf(this.tracker.getId()));
+            //entityplayer.removeQueue.remove(Integer.valueOf(this.tracker.getId())); // Nacho - Async entity tracker
 
             this.trackedPlayerMap.put(entityplayer, true); // Paper
+            this.trackedPlayers.add(entityplayer); // Nacho - Async entity tracker
             Packet packet = this.createPacket(); // IonSpigot
             if (packet == null) return; // IonSpigot - If it's null don't update the client!
 
diff --git a/src/main/java/net/minecraft/server/EntityPlayer.java b/src/main/java/net/minecraft/server/EntityPlayer.java
index 0f6b3b66e..a3897b2f5 100644
--- a/src/main/java/net/minecraft/server/EntityPlayer.java
+++ b/src/main/java/net/minecraft/server/EntityPlayer.java
@@ -35,7 +35,7 @@ public class EntityPlayer extends EntityHuman implements ICrafting {
     public double d;
     public double e;
     public final List<ChunkCoordIntPair> chunkCoordIntPairQueue = Lists.newLinkedList();
-    public final java.util.Deque<Integer> removeQueue = new java.util.ArrayDeque<>(); // PandaSpigot
+    //public final java.util.Deque<Integer> removeQueue = new java.util.ArrayDeque<>(); // PandaSpigot // Nacho - Async entity tracker
     private final ServerStatisticManager bK;
     private float bL = Float.MIN_VALUE;
     private float bM = -1.0E8F;
@@ -51,6 +51,10 @@ public class EntityPlayer extends EntityHuman implements ICrafting {
     public boolean g;
     public int ping;
     public boolean viewingCredits;
+    // Nacho start - Async entity tracker
+    public int playerMapX;
+    public int playerMapZ;
+    // Nacho end
 
     // CraftBukkit start
     public String displayName;
@@ -215,7 +219,8 @@ public class EntityPlayer extends EntityHuman implements ICrafting {
             this.activeContainer = this.defaultContainer;
         }
 
-        while (!this.removeQueue.isEmpty()) {
+        // Nacho start - Async entity tracker
+        /*while (!this.removeQueue.isEmpty()) {
             int i = Math.min(this.removeQueue.size(), Integer.MAX_VALUE);
             int[] aint = new int[i];
             //Iterator iterator = this.removeQueue.iterator(); // PandaSpigot
@@ -226,7 +231,7 @@ public class EntityPlayer extends EntityHuman implements ICrafting {
                 aint[j++] = ((Integer) iterator.next()).intValue();
                 iterator.remove();
             } */
-            Integer integer;
+            /*Integer integer;
             while (j < i && (integer = this.removeQueue.poll()) != null) {
                 aint[j++] = integer;
             }
@@ -234,7 +239,8 @@ public class EntityPlayer extends EntityHuman implements ICrafting {
             // PandaSpigot end
 
             this.playerConnection.sendPacket(new PacketPlayOutEntityDestroy(aint));
-        }
+        }*/
+        // Nacho end
 
         if (!this.chunkCoordIntPairQueue.isEmpty()) {
             ArrayList<Chunk> chunkList = Lists.newArrayList();
@@ -949,9 +955,11 @@ public class EntityPlayer extends EntityHuman implements ICrafting {
         this.bN = -1;
         // PandaSpigot start
         //this.removeQueue.addAll(((EntityPlayer) entityhuman).removeQueue);
-        if (this.removeQueue != ((EntityPlayer) entityhuman).removeQueue) {
+        // Nacho start - Async entity tracker
+        /*if (this.removeQueue != ((EntityPlayer) entityhuman).removeQueue) {
             this.removeQueue.addAll(((EntityPlayer) entityhuman).removeQueue);
-        }
+        }*/
+        // Nacho end
         // PandaSpigot end
     }
 
@@ -1082,12 +1090,15 @@ public class EntityPlayer extends EntityHuman implements ICrafting {
     }
 
     public void d(Entity entity) {
-        if (entity instanceof EntityHuman) {
+        // Nacho start - Async entity tracker
+        /*if (entity instanceof EntityHuman) {
             this.playerConnection.sendPacket(new PacketPlayOutEntityDestroy(new int[] { entity.getId()}));
         } else {
             this.removeQueue.add(Integer.valueOf(entity.getId()));
-        }
+        }*/
+        // Nacho end
 
+        this.playerConnection.sendPacket(new PacketPlayOutEntityDestroy(entity.getId()));
     }
 
     protected void B() {
diff --git a/src/main/java/net/minecraft/server/EntityTracker.java b/src/main/java/net/minecraft/server/EntityTracker.java
index addf86937..0df4d470c 100644
--- a/src/main/java/net/minecraft/server/EntityTracker.java
+++ b/src/main/java/net/minecraft/server/EntityTracker.java
@@ -1,11 +1,8 @@
 package net.minecraft.server;
 
-import com.google.common.collect.Lists;
-import com.google.common.collect.Sets;
-import java.util.ArrayList;
 import java.util.Iterator;
-import java.util.Set;
 import java.util.concurrent.Callable;
+import me.rastrian.dev.utils.IndexedLinkedHashSet;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 
@@ -13,19 +10,42 @@ public class EntityTracker {
 
     private static final Logger a = LogManager.getLogger();
     private final WorldServer world;
+    // Nacho start - Async entity tracker
+    public IndexedLinkedHashSet<EntityTrackerEntry> c = new IndexedLinkedHashSet<>();
+    public IndexedLinkedHashSet<EntityTrackerEntry> getTrackedEntities() { return c; }
+    /*
     private Set<EntityTrackerEntry> c = new io.papermc.paper.util.maplist.ObjectMapList<>(); // IonSpigot - HashSet -> ObjectMapList
-    public IntHashMap<EntityTrackerEntry> trackedEntities = new IntHashMap();
+     */
+    // Nacho end
+    public IntHashMap<EntityTrackerEntry> trackedEntities = new IntHashMap<>(); // tracked entities hash table
+
+    // Nacho start - Async entity tracker
+    private volatile int noTrackDistance = 0; // WindSpigot - volatile
+
+    public int getNoTrackDistance() {
+        return this.noTrackDistance;
+    }
+    public void setNoTrackDistance(int noTrackDistance) {
+        this.noTrackDistance = noTrackDistance;
+    }
+    // Nacho end
+
     private int e;
 
     public EntityTracker(WorldServer worldserver) {
         this.world = worldserver;
-        this.e = worldserver.getMinecraftServer().getPlayerList().d();
+        // Nacho start - Async entity tracker
+        //this.e = worldserver.getMinecraftServer().getPlayerList().d();
+        this.e = 128;
+        // Nacho end
     }
 
     public void track(Entity entity) {
         if (entity instanceof EntityPlayer) {
             this.addEntity(entity, 512, 2);
-            EntityPlayer entityplayer = (EntityPlayer) entity;
+
+            // Nacho start - Async entity tracker
+            /*EntityPlayer entityplayer = (EntityPlayer) entity;
             Iterator iterator = this.c.iterator();
 
             while (iterator.hasNext()) {
@@ -34,7 +54,8 @@ public class EntityTracker {
                 if (entitytrackerentry.tracker != entityplayer) {
                     entitytrackerentry.updatePlayer(entityplayer);
                 }
-            }
+            }*/
+            // Nacho end
         } else if (entity instanceof EntityFishingHook) {
             this.addEntity(entity, 64, 5, true);
         } else if (entity instanceof EntityArrow) {
@@ -102,14 +123,20 @@ public class EntityTracker {
 
         try {
             if (this.trackedEntities.b(entity.getId())) {
-                throw new IllegalStateException("Entity is already tracked!");
+                // Nacho start - Async entity tracker
+                //throw new IllegalStateException("Entity is already tracked!");
+                untrackEntity(entity);
+                // Nacho end
             }
 
             EntityTrackerEntry entitytrackerentry = createTracker(entity, i, j, flag); // IonSpigot
 
             this.c.add(entitytrackerentry);
             this.trackedEntities.a(entity.getId(), entitytrackerentry);
-            entitytrackerentry.scanPlayers(this.world.players);
+            // Nacho start - Async entity tracker
+            //entitytrackerentry.scanPlayers(this.world.players);
+            entitytrackerentry.addNearPlayers();
+            // Nacho end
         } catch (Throwable throwable) {
             CrashReport crashreport = CrashReport.a(throwable, "Adding entity to track");
             CrashReportSystemDetails crashreportsystemdetails = crashreport.a("Entity To Track");
@@ -145,11 +172,11 @@ public class EntityTracker {
 
     }
     // IonSpigot start
-    private EntityTrackerEntry createTracker(Entity entity, int i, int j, boolean flag) {
+    protected EntityTrackerEntry createTracker(Entity entity, int i, int j, boolean flag) {
         if (entity.isCannoningEntity && world.ionConfigTitanium.tnt.useFasterTracker) {
-            return new me.suicidalkids.ion.visuals.CannonTrackerEntry(entity, i, j, flag);
+            return new me.suicidalkids.ion.visuals.CannonTrackerEntry(this, entity, i, j, flag);
         } else {
-            return new EntityTrackerEntry(entity, i, j, flag);
+            return new EntityTrackerEntry(this, entity, i, j, flag);
         }
     }
     // IonSpigot end
@@ -177,7 +204,11 @@ public class EntityTracker {
     }
 
     public void updatePlayers() {
-        ArrayList arraylist = Lists.newArrayList();
+        // Nacho start - Async entity tracker
+        for (EntityTrackerEntry entry : c) {
+            entry.update();
+        }
+        /*ArrayList arraylist = Lists.newArrayList();
         Iterator iterator = this.c.iterator();
 
         while (iterator.hasNext()) {
@@ -200,8 +231,8 @@ public class EntityTracker {
                     entitytrackerentry1.updatePlayer(entityplayer);
                 }
             }
-        }
-
+        }*/
+        // Nacho end
     }
 
     public void a(EntityPlayer entityplayer) {
@@ -211,7 +242,10 @@ public class EntityTracker {
             EntityTrackerEntry entitytrackerentry = (EntityTrackerEntry) iterator.next();
 
             if (entitytrackerentry.tracker == entityplayer) {
-                entitytrackerentry.scanPlayers(this.world.players);
+                // Nacho start - Async entity tracker
+                //entitytrackerentry.scanPlayers(this.world.players);
+                entitytrackerentry.addNearPlayers();
+                // Nacho end
             } else {
                 entitytrackerentry.updatePlayer(entityplayer);
             }
@@ -252,7 +286,8 @@ public class EntityTracker {
         return this.c.iterator();
     }
 
-    public void a(EntityPlayer entityplayer, Chunk chunk) {
+    // Nacho start - Async entity tracker
+    /*public void a(EntityPlayer entityplayer, Chunk chunk) {
         Iterator iterator = this.c.iterator();
 
         while (iterator.hasNext()) {
@@ -263,5 +298,6 @@ public class EntityTracker {
             }
         }
 
-    }
+    }*/
+    // Nacho end
 }
diff --git a/src/main/java/net/minecraft/server/EntityTrackerEntry.java b/src/main/java/net/minecraft/server/EntityTrackerEntry.java
index 651e5bfa0..4bf441d7d 100644
--- a/src/main/java/net/minecraft/server/EntityTrackerEntry.java
+++ b/src/main/java/net/minecraft/server/EntityTrackerEntry.java
@@ -1,10 +1,13 @@
 package net.minecraft.server;
 
 import com.google.common.collect.Sets;
+import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Set;
+import java.util.function.Consumer;
+import net.titanium.config.TitaniumConfig;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 
@@ -46,7 +49,16 @@ public class EntityTrackerEntry {
     public Set<EntityPlayer> trackedPlayers = trackedPlayerMap.keySet();
     // PaperSpigot end
 
-    public EntityTrackerEntry(Entity entity, int i, int j, boolean flag) {
+    // Nacho start - Async entity tracker
+    protected List<EntityPlayer> toRemove = new ArrayList<>();
+    protected EntityTracker entityTracker;
+    protected int addRemoveRate;
+    protected int addRemoveCooldown;
+    protected boolean withinNoTrack = false;
+
+    public EntityTrackerEntry(EntityTracker entityTracker, Entity entity, int i, int j, boolean flag) {
+        this.entityTracker = entityTracker;
+        // Nacho end
         this.tracker = entity;
         this.b = i;
         this.c = j;
@@ -58,6 +70,19 @@ public class EntityTrackerEntry {
         this.xRot = MathHelper.d(entity.pitch * 256.0F / 360.0F);
         this.i = MathHelper.d(entity.getHeadRotation() * 256.0F / 360.0F);
         this.y = entity.onGround;
+
+        // Nacho start - Async entity tracker
+        if (!TitaniumConfig.get().entityTracker.async.enabled) {
+            this.addRemoveRate = 100;
+        } else if (this.tracker instanceof EntityArrow || this.tracker instanceof EntityProjectile) {
+            this.addRemoveRate = 5; // projectile things
+        } else if (this.tracker instanceof EntityPlayer) {
+            this.addRemoveRate = 5; // players
+        } else {
+            this.addRemoveRate = 10; // default
+        }
+        this.addRemoveCooldown = this.tracker.getId() % addRemoveRate;
+        // Nacho end
     }
 
     public boolean equals(Object object) {
@@ -68,6 +93,79 @@ public class EntityTrackerEntry {
         return this.tracker.getId();
     }
 
+    // Nacho start - Async entity tracker
+    public void update() {
+        this.withinNoTrack = this.withinNoTrack();
+        if (--this.addRemoveCooldown <= 0) {
+            this.removeFarPlayers();
+            this.addNearPlayers();
+            this.addRemoveCooldown = this.addRemoveRate;
+        }
+
+        this.track(null);
+    }
+
+    protected void removeFarPlayers() {
+        if (this.withinNoTrack) {
+            toRemove.addAll(this.trackedPlayers);
+            processToRemove();
+            return;
+        }
+
+        for (EntityPlayer entityplayer : (Collection<EntityPlayer>) trackedPlayers) {
+            double d0 = entityplayer.locX - this.tracker.locX;
+            double d1 = entityplayer.locZ - this.tracker.locZ;
+            int range = this.getRange();
+
+            if (!(d0 >= (double) (-range) && d0 <= (double) range && d1 >= (double) (-range) && d1 <= (double) range) || withinNoTrack()) {
+                toRemove.add(entityplayer);
+            }
+        }
+
+        this.processToRemove();
+    }
+
+    protected void processToRemove() {
+        for (EntityPlayer entityPlayer : toRemove) {
+            entityPlayer.d(this.tracker);
+            this.trackedPlayers.remove(entityPlayer);
+        }
+
+        toRemove.clear();
+    }
+
+    protected void addNearPlayers() {
+        addNearPlayers(false);
+    }
+
+    protected void addNearPlayers(boolean updateCooldown) {
+        if (this.withinNoTrack) return;
+        if (updateCooldown) this.addRemoveCooldown = addRemoveRate;
+        this.tracker.world.playerMap.forEachNearby(this.tracker.locX, this.tracker.locY, this.tracker.locZ, this.getRange(), false, addNearPlayersConsumer);
+    }
+
+    protected boolean withinNoTrack() {
+        return this.withinNoTrack(this.tracker);
+    }
+
+    protected boolean withinNoTrack(Entity entity) {
+        if (!(entity instanceof EntityPlayer)) return false; // ensure all non-players are always tracked
+        double xDistSqrd = entity.locX * entity.locX;
+        double zDistSqrd = entity.locZ * entity.locZ;
+
+        int noTrackDistanceSqrd = entityTracker.getNoTrackDistance() * entityTracker.getNoTrackDistance();
+        return noTrackDistanceSqrd != 0 && xDistSqrd <= noTrackDistanceSqrd && zDistSqrd <= noTrackDistanceSqrd;
+    }
+
+    private final Consumer<EntityPlayer> addNearPlayersConsumer = new Consumer<EntityPlayer>() {
+
+        @Override
+        public void accept(EntityPlayer entityPlayer) {
+            updatePlayer(entityPlayer);
+        }
+    };
+    // Nacho end
+
     public void track(List<EntityHuman> list) {
         this.n = false;
         if (!this.isMoving || this.tracker.e(this.q, this.r, this.s) > 16.0D) {
@@ -76,7 +174,7 @@ public class EntityTrackerEntry {
             this.s = this.tracker.locZ;
             this.isMoving = true;
             this.n = true;
-            this.scanPlayers(list);
+            //this.scanPlayers(list); // Nacho - Async entity tracker
         }
 
         if (this.w != this.tracker.vehicle || this.tracker.vehicle != null && this.m % 60 == 0) {
@@ -154,9 +252,11 @@ public class EntityTrackerEntry {
                         this.y = this.tracker.onGround;
                         this.v = 0;
                         // CraftBukkit start - Refresh list of who can see a player before sending teleport packet
-                        if (this.tracker instanceof EntityPlayer) {
+                        // Nacho start - Async entity tracker
+                        /*if (this.tracker instanceof EntityPlayer) {
                             this.scanPlayers(new java.util.ArrayList(this.tracker.world.players)); // [SportPaper-0203] Fix Teleport Invisibility this.trackedPlayers -> this.tracker.world.players
-                        }
+                        }*/
+                        // Nacho end
                         // CraftBukkit end
                         object = new PacketPlayOutEntityTeleport(this.tracker.getId(), i, j, k, (byte) l, (byte) i1, this.tracker.onGround);
                     }
@@ -334,10 +434,11 @@ public class EntityTrackerEntry {
     }
 
     public void updatePlayer(EntityPlayer entityplayer) {
-        org.spigotmc.AsyncCatcher.catchOp( "player tracker update"); // Spigot
+        //org.spigotmc.AsyncCatcher.catchOp( "player tracker update"); // Spigot // Nacho - Async entity tracker
         if (entityplayer != this.tracker) {
             if (this.c(entityplayer)) {
                 if (!this.trackedPlayers.contains(entityplayer) && (this.e(entityplayer) || this.tracker.attachedToPlayer)) {
+                    if (this.tracker instanceof EntityPlayer && withinNoTrack()) return; // Nacho - Async entity tracker
                     // CraftBukkit start - respect vanish API
                     if (this.tracker instanceof EntityPlayer) {
                         Player player = ((EntityPlayer) this.tracker).getBukkitEntity();
@@ -346,7 +447,7 @@ public class EntityTrackerEntry {
                         }
                     }
 
-                    entityplayer.removeQueue.remove(Integer.valueOf(this.tracker.getId()));
+                    //entityplayer.removeQueue.remove(Integer.valueOf(this.tracker.getId())); // Nacho - Async entity tracker
                     // CraftBukkit end
                     this.trackedPlayerMap.put(entityplayer, true); // PaperBukkit
                     Packet packet = this.c();
@@ -455,12 +556,14 @@ public class EntityTrackerEntry {
         return entityplayer.u().getPlayerChunkMap().a(entityplayer, this.tracker.ae, this.tracker.ag);
     }
 
-    public void scanPlayers(List<EntityHuman> list) {
+    // Nacho start - Async entity tracker
+    /*public void scanPlayers(List<EntityHuman> list) {
         for (int i = 0; i < list.size(); ++i) {
             this.updatePlayer((EntityPlayer) list.get(i));
         }
 
-    }
+    }*/
+    // Nacho end
 
     protected Packet createPacket() {
         return this.c();
@@ -576,6 +679,15 @@ public class EntityTrackerEntry {
         }
     }
 
+    // Nacho start - Async entity tracker
+    public int getRange() {
+        if (this.tracker.passenger == null) {
+            return this.b;
+        }
+        return Math.max(this.b, org.spigotmc.TrackingRange.getEntityTrackingRange(this.tracker.passenger, 0));
+    }
+    // Nacho end
+
     public void clear(EntityPlayer entityplayer) {
         org.spigotmc.AsyncCatcher.catchOp( "player tracker clear"); // Spigot
         if (this.trackedPlayers.contains(entityplayer)) {
diff --git a/src/main/java/net/minecraft/server/PlayerList.java b/src/main/java/net/minecraft/server/PlayerList.java
index 5bc1d1860..57294b238 100644
--- a/src/main/java/net/minecraft/server/PlayerList.java
+++ b/src/main/java/net/minecraft/server/PlayerList.java
@@ -356,6 +356,7 @@ public abstract class PlayerList {
 
     public void d(EntityPlayer entityplayer) {
         entityplayer.u().getPlayerChunkMap().movePlayer(entityplayer);
+        entityplayer.world.playerMap.move(entityplayer);
     }
 
     public String disconnect(EntityPlayer entityplayer) { // CraftBukkit - return string
diff --git a/src/main/java/net/minecraft/server/World.java b/src/main/java/net/minecraft/server/World.java
index 44e5fe295..2df6fa3d7 100644
--- a/src/main/java/net/minecraft/server/World.java
+++ b/src/main/java/net/minecraft/server/World.java
@@ -5,6 +5,7 @@ import com.google.common.collect.Lists;
 import com.google.common.collect.Maps;
 import com.google.common.collect.Sets;
 import it.unimi.dsi.fastutil.objects.ObjectArrayList;
+import me.rastrian.dev.PlayerMap;
 import me.suicidalkids.ion.blocks.movement.MovementCache;
 import net.titanium.config.IonWorldConfig;
 import net.titanium.config.PaperWorldConfig;
@@ -146,6 +147,7 @@ public abstract class World implements IBlockAccess {
     private org.spigotmc.TickLimiter entityLimiter;
     private org.spigotmc.TickLimiter tileLimiter;
     private int tileTickPosition;
+    public final PlayerMap playerMap = new PlayerMap(); // Nacho - Async entity tracker
     public ExecutorService lightingExecutor = Executors.newSingleThreadExecutor(new ThreadFactoryBuilder().setNameFormat("PaperSpigot - Lighting Thread").build()); // PaperSpigot - Asynchronous lighting updates
     public final Map<Explosion.CacheKey, Float> explosionDensityCache = new HashMap<Explosion.CacheKey, Float>(); // PaperSpigot - Optimize explosions
 
@@ -1148,6 +1150,7 @@ public abstract class World implements IBlockAccess {
                 EntityHuman entityhuman = (EntityHuman) entity;
 
                 this.players.add(entityhuman);
+                this.playerMap.add((EntityPlayer) entityhuman); // Nacho - Async entity tracker
                 this.everyoneSleeping();
             }
 
@@ -1187,6 +1190,7 @@ public abstract class World implements IBlockAccess {
         if (entity instanceof EntityHuman) {
             this.players.remove(entity);
             this.worldMaps.removeTrackedPlayer((EntityHuman) entity); // FlamePaper - Minetick fix memory leaks
+            this.playerMap.remove((EntityPlayer) entity); // Nacho - Async entity tracker
             // Spigot start
             for ( Object o : worldMaps.c )
             {
@@ -1216,6 +1220,7 @@ public abstract class World implements IBlockAccess {
         if (entity instanceof EntityHuman) {
             this.players.remove(entity);
             this.worldMaps.removeTrackedPlayer((EntityHuman) entity); // FlamePaper - Minetick fix memory leaks
+            this.playerMap.remove((EntityPlayer) entity); // Nacho - Async entity tracker
             this.everyoneSleeping();
         }
 
@@ -2960,11 +2965,14 @@ public abstract class World implements IBlockAccess {
     }
 
     public EntityHuman findNearbyPlayer(double d0, double d1, double d2, double d3) {
+        if (0 <= d3 && d3 <= 64) { return this.playerMap.getNearestPlayer(d0, d1, d2, d3); } // Nacho - Async entity tracker
         double d4 = -1.0D;
         EntityHuman entityhuman = null;
 
-        for (int i = 0; i < this.players.size(); ++i) {
-            EntityHuman entityhuman1 = (EntityHuman) this.players.get(i);
+        // Nacho start - Async entity tracker
+        /*for (int i = 0; i < this.players.size(); ++i) {
+            EntityHuman entityhuman1 = (EntityHuman) this.players.get(i);*/
+        for (EntityHuman entityhuman1 : a(EntityHuman.class, AxisAlignedBB.a(d0 - d3, d1 - d3, d2 - d3, d0 + d3, d1 + d3, d2 + d3))) { // Nacho end
             // CraftBukkit start - Fixed an NPE
             if (entityhuman1 == null || entityhuman1.dead) {
                 continue;
@@ -3006,6 +3014,7 @@ public abstract class World implements IBlockAccess {
     }
 
     public EntityHuman findNearbyPlayerWhoAffectsSpawning(double d0, double d1, double d2, double d3) {
+        if (0 <= d3 && d3 <= 64.0) { return this.playerMap.getNearbyPlayer(d0, d1, d2, d3, true); } // Nacho - Async entity tracker
         double d4 = -1.0D;
         EntityHuman entityhuman = null;
 
diff --git a/src/main/java/net/minecraft/server/WorldManager.java b/src/main/java/net/minecraft/server/WorldManager.java
index 7a9027fc6..8d3e3c971 100644
--- a/src/main/java/net/minecraft/server/WorldManager.java
+++ b/src/main/java/net/minecraft/server/WorldManager.java
@@ -25,12 +25,18 @@ public class WorldManager implements IWorldAccess {
 
     public void a(String s, double d0, double d1, double d2, float f, float f1) {
         // CraftBukkit - this.world.dimension
-        this.a.getPlayerList().sendPacketNearby(d0, d1, d2, f > 1.0F ? (double) (16.0F * f) : 16.0D, this.world.dimension, new PacketPlayOutNamedSoundEffect(s, d0, d1, d2, f, f1));
+        // Nacho start - Async entity tracker
+        //this.a.getPlayerList().sendPacketNearby(d0, d1, d2, f > 1.0F ? (double) (16.0F * f) : 16.0D, this.world.dimension, new PacketPlayOutNamedSoundEffect(s, d0, d1, d2, f, f1));
+        this.world.playerMap.sendPacketNearby(null, d0, d1, d2, f > 1.0F ? (double) (16.0F * f) : 16.0D, new PacketPlayOutNamedSoundEffect(s, d0, d1, d2, f, f1), false);
+        // Nacho end
     }
 
     public void a(EntityHuman entityhuman, String s, double d0, double d1, double d2, float f, float f1) {
         // CraftBukkit - this.world.dimension, // Paper - this.world.dimension -> this.world
-        this.a.getPlayerList().sendPacketNearby(entityhuman, d0, d1, d2, f > 1.0F ? (double) (16.0F * f) : 16.0D, this.world, new PacketPlayOutNamedSoundEffect(s, d0, d1, d2, f, f1));
+        // Nacho start - Async entity tracker
+        //this.a.getPlayerList().sendPacketNearby(entityhuman, d0, d1, d2, f > 1.0F ? (double) (16.0F * f) : 16.0D, this.world, new PacketPlayOutNamedSoundEffect(s, d0, d1, d2, f, f1));
+        this.world.playerMap.sendPacketNearby((EntityPlayer) entityhuman, d0, d1, d2, f > 1.0F ? (double) (16.0F * f) : 16.0D, new PacketPlayOutNamedSoundEffect(s, d0, d1, d2, f, f1), false);
+        // Nacho end
     }
 
     public void a(int i, int j, int k, int l, int i1, int j1) {}
@@ -45,7 +51,10 @@ public class WorldManager implements IWorldAccess {
 
     public void a(EntityHuman entityhuman, int i, BlockPosition blockposition, int j) {
         // CraftBukkit - this.world.dimension
-        this.a.getPlayerList().sendPacketNearby(entityhuman, (double) blockposition.getX(), (double) blockposition.getY(), (double) blockposition.getZ(), 64.0D, this.world, new PacketPlayOutWorldEvent(i, blockposition, j, false));
+        // Nacho start - Async entity tracker
+        //this.a.getPlayerList().sendPacketNearby(entityhuman, (double) blockposition.getX(), (double) blockposition.getY(), (double) blockposition.getZ(), 64.0D, this.world, new PacketPlayOutWorldEvent(i, blockposition, j, false));
+        this.world.playerMap.sendPacketNearby((EntityPlayer) entityhuman, blockposition.getX(), blockposition.getY(), blockposition.getZ(), 64.0D, new PacketPlayOutWorldEvent(i, blockposition, j, false), false);
+        // Nacho end
     }
 
     public void a(int i, BlockPosition blockposition, int j) {
@@ -82,12 +91,15 @@ public class WorldManager implements IWorldAccess {
                 }
                 // CraftBukkit end
 
-                if (d0 * d0 + d1 * d1 + d2 * d2 < 1024.0D) {
+                // Nacho start - Async entity tracker
+                /*if (d0 * d0 + d1 * d1 + d2 * d2 < 1024.0D) {*/
                     // SportPaper start
                     if (packet == null) packet = new PacketPlayOutBlockBreakAnimation(i, blockposition, j);
-                    entityplayer.playerConnection.sendPacket(packet);
+                    //entityplayer.playerConnection.sendPacket(packet);
+                    this.world.playerMap.sendPacketNearby(entityplayer, blockposition.getX(), blockposition.getY(), blockposition.getZ(), 32.0D, packet, false);
                     // SportPaper end
-                }
+                /*}*/
+                // Nacho end
             }
         }
 
diff --git a/src/main/java/net/minecraft/server/WorldServer.java b/src/main/java/net/minecraft/server/WorldServer.java
index 7c004dd77..7a6298489 100644
--- a/src/main/java/net/minecraft/server/WorldServer.java
+++ b/src/main/java/net/minecraft/server/WorldServer.java
@@ -5,6 +5,7 @@ import com.google.common.collect.Lists;
 import com.google.common.collect.Maps;
 import com.google.common.collect.Sets;
 import com.google.common.util.concurrent.ListenableFuture;
+import ga.windpvp.windspigot.async.entitytracker.AsyncEntityTracker;
 import java.util.ArrayList;
 import java.util.Iterator;
 import java.util.List;
@@ -64,7 +65,12 @@ public class WorldServer extends World implements IAsyncTaskHandler {
         worlddata.world = this;
         // CraftBukkit end
         this.server = minecraftserver;
-        this.tracker = new EntityTracker(this);
+        // WindSpigot - Async entity tracker
+        if (TitaniumConfig.get().entityTracker.async.enabled) {
+            this.tracker = new AsyncEntityTracker(this);
+        } else {
+            this.tracker = new EntityTracker(this);
+        }
         this.manager = new PlayerChunkMap(this, spigotConfigTitanium.viewDistance); // Spigot
         this.worldProvider.a(this);
         this.chunkProvider = this.k();
diff --git a/src/main/java/net/titanium/config/TitaniumConfig.java b/src/main/java/net/titanium/config/TitaniumConfig.java
index 555f3dfa6..a192a9a24 100644
--- a/src/main/java/net/titanium/config/TitaniumConfig.java
+++ b/src/main/java/net/titanium/config/TitaniumConfig.java
@@ -148,6 +148,7 @@ TitaniumConfig extends TitaniumConfigSection {
         public IO io = new IO();
 
         public static class IO extends TitaniumConfigSection {
+
             @Comment("The amount of threads to use for chunk loading (start value).")
             public int baseThreads = 2; // PaperSpigot - Bumped value
 
@@ -155,6 +156,7 @@ TitaniumConfig extends TitaniumConfigSection {
             @Comment("This values represents how many players are needed to create a new thread.")
             @Comment("For eg. base-threads is 2, on server is 100 players, when one more joins server new thread will be created and so on.")
             public int playersPerThread = 50;
+
         }
 
     }
@@ -175,6 +177,26 @@ TitaniumConfig extends TitaniumConfigSection {
 
     }
 
+    public EntityTracker entityTracker = new EntityTracker();
+
+    public static class EntityTracker extends TitaniumConfigSection {
+
+        public Async async = new Async();
+
+        public static class Async extends TitaniumConfigSection {
+
+            @Comment("Whether to use asynchronous entity tracking.")
+            @Comment("Enabling this could be good idea since it can have good impact on performance.")
+            @Comment("Disable it if something doesn't work properly (for eg. anticheat plugin).")
+            public boolean enabled = false;
+
+            @Comment("How many threads to use for entity tracking.")
+            public int threads = 4;
+
+        }
+
+    }
+
     @Comment("When this option is enabled, the server will create a directory `legacy_configs` with files like bukkit.yml, spigot.yml etc.")
     @Comment("Changing option there will not affect the server, it's only mirror of this file.")
     @Comment("Enable this option only if some of your plugins are not compatible with the new configs.")
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
index afed8b691..ed8338ce8 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
@@ -2,6 +2,7 @@ package org.bukkit.craftbukkit.entity;
 
 import com.google.common.base.Preconditions;
 import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Sets;
 import com.mojang.authlib.GameProfile;
 import io.netty.buffer.Unpooled;
 
@@ -76,7 +77,7 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
     private boolean hasPlayedBefore = false;
     private final ConversationTracker conversationTracker = new ConversationTracker();
     private final Set<String> channels = new HashSet<String>();
-    private final Set<UUID> hiddenPlayers = new HashSet<UUID>();
+    private final Set<UUID> hiddenPlayers = Sets.newConcurrentHashSet(); // WindSpigot - concurrent collection
     private int hash = 0;
     private double health = 20;
     private boolean scaledHealth = false;
diff --git a/src/main/java/org/spigotmc/TrackingRange.java b/src/main/java/org/spigotmc/TrackingRange.java
index f5e38264a..a4dbfdf0b 100644
--- a/src/main/java/org/spigotmc/TrackingRange.java
+++ b/src/main/java/org/spigotmc/TrackingRange.java
@@ -1,7 +1,10 @@
 package org.spigotmc;
 
 import net.minecraft.server.Entity;
+import net.minecraft.server.EntityArrow;
+import net.minecraft.server.EntityEnderPearl;
 import net.minecraft.server.EntityExperienceOrb;
+import net.minecraft.server.EntityFishingHook;
 import net.minecraft.server.EntityGhast;
 import net.minecraft.server.EntityItem;
 import net.minecraft.server.EntityItemFrame;
@@ -24,8 +27,7 @@ public class TrackingRange
     {
         SpigotWorldConfig config = entity.world.spigotConfigTitanium;
         SpigotWorldConfig.EntityTrackingRange trackingConfig = config.entityTrackingRange;
-        if ( entity instanceof EntityPlayer )
-        {
+        if ( entity instanceof EntityPlayer || entity instanceof EntityArrow || entity instanceof EntityEnderPearl || entity instanceof EntityFishingHook) {
             return trackingConfig.players;
         }  else if ( entity.activationType == 1 )
         {
-- 
2.36.0.windows.1

